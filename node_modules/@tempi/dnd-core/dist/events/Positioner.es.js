import { ROOT_NODE, getDOMInfo } from '@tempi/dnd-utils';
import findPosition from './findPosition.es.js';
import { getNodesFromSelector } from '../utils/getNodesFromSelector.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const _Positioner = class {
  constructor(store, dragTarget) {
    this.store = store;
    this.dragTarget = dragTarget;
    this.currentIndicator = null;
    this.currentDropTargetId = null;
    this.currentDropTargetCanvasAncestorId = null;
    this.currentTargetId = null;
    this.currentTargetChildDimensions = null;
    this.currentIndicator = null;
    this.dragError = null;
    this.draggedNodes = this.getDraggedNodes();
    this.validateDraggedNodes();
    this.onScrollListener = this.onScroll.bind(this);
    window.addEventListener("scroll", this.onScrollListener, true);
  }
  cleanup() {
    window.removeEventListener("scroll", this.onScrollListener, true);
  }
  onScroll(e) {
    const scrollBody = e.target;
    const rootNode = this.store.query.node(ROOT_NODE).get();
    const shouldClearChildDimensionsCache = scrollBody instanceof Element && rootNode && rootNode.dom && scrollBody.contains(rootNode.dom);
    if (!shouldClearChildDimensionsCache) {
      return;
    }
    this.currentTargetChildDimensions = null;
  }
  getDraggedNodes() {
    if (this.dragTarget.type === "new") {
      return getNodesFromSelector(
        this.store.query.getNodes(),
        this.dragTarget.tree.nodes[this.dragTarget.tree.rootNodeId]
      );
    }
    return getNodesFromSelector(
      this.store.query.getNodes(),
      this.dragTarget.nodes
    );
  }
  validateDraggedNodes() {
    if (this.dragTarget.type === "new") {
      return;
    }
    this.draggedNodes.forEach(({ node, exists }) => {
      if (!exists) {
        return;
      }
      this.store.query.node(node.id).isDraggable((err) => {
        this.dragError = err;
      });
    });
  }
  isNearBorders(domInfo, x, y) {
    const { top, bottom, left, right } = domInfo;
    if (top + _Positioner.BORDER_OFFSET > y || bottom - _Positioner.BORDER_OFFSET < y || left + _Positioner.BORDER_OFFSET > x || right - _Positioner.BORDER_OFFSET < x) {
      return true;
    }
    return false;
  }
  isDiff(newPosition) {
    if (this.currentIndicator && this.currentIndicator.placement.parent.id === newPosition.parent.id && this.currentIndicator.placement.index === newPosition.index && this.currentIndicator.placement.where === newPosition.where) {
      return false;
    }
    return true;
  }
  getChildDimensions(newParentNode) {
    const existingTargetChildDimensions = this.currentTargetChildDimensions;
    if (this.currentTargetId === newParentNode.id && existingTargetChildDimensions) {
      return existingTargetChildDimensions;
    }
    return newParentNode.data.nodes.reduce((result, id) => {
      const dom = this.store.query.node(id).get().dom;
      if (dom) {
        result.push(__spreadValues({
          id
        }, getDOMInfo(dom)));
      }
      return result;
    }, []);
  }
  getCanvasAncestor(dropTargetId) {
    if (dropTargetId === this.currentDropTargetId && this.currentDropTargetCanvasAncestorId) {
      const node = this.store.query.node(this.currentDropTargetCanvasAncestorId).get();
      if (node) {
        return node;
      }
    }
    const getCanvas = (nodeId) => {
      const node = this.store.query.node(nodeId).get();
      if (node && node.data.isCanvas) {
        return node;
      }
      if (!node.data.parent) {
        return null;
      }
      return getCanvas(node.data.parent);
    };
    return getCanvas(dropTargetId);
  }
  computeIndicator(dropTargetId, x, y) {
    let newParentNode = this.getCanvasAncestor(dropTargetId);
    if (!newParentNode) {
      return;
    }
    this.currentDropTargetId = dropTargetId;
    this.currentDropTargetCanvasAncestorId = newParentNode.id;
    if (newParentNode.data.parent && this.isNearBorders(getDOMInfo(newParentNode.dom), x, y) && !this.store.query.node(newParentNode.id).isLinkedNode()) {
      newParentNode = this.store.query.node(newParentNode.data.parent).get();
    }
    if (!newParentNode) {
      return;
    }
    this.currentTargetChildDimensions = this.getChildDimensions(newParentNode);
    this.currentTargetId = newParentNode.id;
    const position = findPosition(
      newParentNode,
      this.currentTargetChildDimensions,
      x,
      y
    );
    if (!this.isDiff(position)) {
      return;
    }
    let error = this.dragError;
    if (!error) {
      this.store.query.node(newParentNode.id).isDroppable(
        this.draggedNodes.map((sourceNode) => sourceNode.node),
        (dropError) => {
          error = dropError;
        }
      );
    }
    const currentNodeId = newParentNode.data.nodes[position.index];
    const currentNode = currentNodeId && this.store.query.node(currentNodeId).get();
    this.currentIndicator = {
      placement: __spreadProps(__spreadValues({}, position), {
        currentNode
      }),
      error
    };
    return this.currentIndicator;
  }
  getIndicator() {
    return this.currentIndicator;
  }
};
let Positioner = _Positioner;
Positioner.BORDER_OFFSET = 10;

export { Positioner };
