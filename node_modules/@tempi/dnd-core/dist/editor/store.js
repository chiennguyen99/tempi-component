'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dndUtils = require('@tempi/dnd-utils');
var actions = require('./actions.js');
var query = require('./query.js');
var DefaultEventHandlers = require('../events/DefaultEventHandlers.js');

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const editorInitialState = {
  nodes: {},
  events: {
    dragged: /* @__PURE__ */ new Set(),
    selected: /* @__PURE__ */ new Set(),
    hovered: /* @__PURE__ */ new Set()
  },
  indicator: null,
  handlers: null,
  options: {
    onNodesChange: () => null,
    onRender: ({ render }) => render,
    onBeforeMoveEnd: () => null,
    resolver: {},
    enabled: true,
    indicator: {
      error: "red",
      success: "rgb(98, 196, 98)"
    },
    handlers: (store) => new DefaultEventHandlers.DefaultEventHandlers({
      store,
      isMultiSelectEnabled: (e) => !!e.metaKey
    }),
    normalizeNodes: () => {
    }
  }
};
const ActionMethodsWithConfig = {
  methods: actions.ActionMethods,
  ignoreHistoryForActions: [
    "setDOM",
    "setNodeEvent",
    "selectNode",
    "clearEvents",
    "setOptions",
    "setIndicator"
  ],
  normalizeHistory: (state) => {
    Object.keys(state.events).forEach((eventName) => {
      const nodeIds = Array.from(state.events[eventName] || []);
      nodeIds.forEach((id) => {
        if (!state.nodes[id]) {
          state.events[eventName].delete(id);
        }
      });
    });
    Object.keys(state.nodes).forEach((id) => {
      const node = state.nodes[id];
      Object.keys(node.events).forEach((eventName) => {
        const isEventActive = !!node.events[eventName];
        if (isEventActive && state.events[eventName] && !state.events[eventName].has(node.id)) {
          node.events[eventName] = false;
        }
      });
    });
  }
};
const useEditorStore = (options, patchListener) => {
  return dndUtils.useMethods(
    ActionMethodsWithConfig,
    __spreadProps(__spreadValues({}, editorInitialState), {
      options: __spreadValues(__spreadValues({}, editorInitialState.options), options)
    }),
    query.QueryMethods,
    patchListener
  );
};

exports.ActionMethodsWithConfig = ActionMethodsWithConfig;
exports.editorInitialState = editorInitialState;
exports.useEditorStore = useEditorStore;
