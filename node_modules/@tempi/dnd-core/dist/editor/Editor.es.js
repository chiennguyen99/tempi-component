import { jsx } from 'react/jsx-runtime';
import { ERROR_RESOLVER_NOT_AN_OBJECT, HISTORY_ACTIONS } from '@tempi/dnd-utils';
import pickBy from 'lodash.pickby';
import { useMemo, useEffect } from 'react';
import invariant from 'tiny-invariant';
import { EditorContext } from './EditorContext.es.js';
import { useEditorStore } from './store.es.js';
import { Events } from '../events/Events.es.js';

var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Editor = ({
  children,
  onRender,
  onNodesChange,
  onBeforeMoveEnd,
  resolver,
  enabled,
  indicator
}) => {
  if (resolver !== void 0) {
    invariant(
      typeof resolver === "object" && !Array.isArray(resolver),
      ERROR_RESOLVER_NOT_AN_OBJECT
    );
  }
  const options = useMemo(() => {
    return pickBy(
      {
        onRender,
        onNodesChange,
        onBeforeMoveEnd,
        resolver,
        enabled,
        indicator
      },
      (value) => value !== void 0
    );
  }, [enabled, indicator, onBeforeMoveEnd, onNodesChange, onRender, resolver]);
  const context = useEditorStore(
    options,
    (state, previousState, actionPerformedWithPatches, query, normalizer) => {
      if (!actionPerformedWithPatches) {
        return;
      }
      const _a = actionPerformedWithPatches, { patches } = _a, actionPerformed = __objRest(_a, ["patches"]);
      for (let i = 0; i < patches.length; i++) {
        const { path } = patches[i];
        const isModifyingNodeData = path.length > 2 && path[0] === "nodes" && path[2] === "data";
        const actionType = actionPerformed.type;
        if ([HISTORY_ACTIONS.IGNORE, HISTORY_ACTIONS.THROTTLE].includes(
          actionType
        ) && actionPerformed.params) {
          actionPerformed.type = actionPerformed.params[0];
        }
        if (["setState", "deserialize"].includes(actionPerformed.type) || isModifyingNodeData) {
          normalizer((draft) => {
            if (state.options.normalizeNodes) {
              state.options.normalizeNodes(
                draft,
                previousState,
                actionPerformed,
                query
              );
            }
          });
          break;
        }
      }
    }
  );
  useEffect(() => {
    if (context && options) {
      context.actions.setOptions((editorOptions) => {
        Object.assign(editorOptions, options);
      });
    }
  }, [context, options]);
  useEffect(() => {
    context.subscribe(
      (_) => ({
        json: context.query.serialize()
      }),
      () => {
        context.query.getOptions().onNodesChange(context.query);
      }
    );
  }, [context]);
  return context ? /* @__PURE__ */ jsx(EditorContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsx(Events, {
      children
    })
  }) : null;
};

export { Editor };
