import { useBuilder, useProp, useNode } from '@tempi/core-editor';
import { undoDepth, redoDepth } from '@tiptap/pm/history';
import { useEditor } from '@tiptap/react';
import { useState, useRef, useEffect } from 'react';
import { ADD_TO_HISTORY_KEY } from './constants.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const useCustomTiptap = (configs, propKey) => {
  const { setIsEditingText } = useBuilder();
  const [text, setText] = useProp(propKey);
  const { isActiveNode } = useNode((node) => ({
    isActiveNode: node.events.selected
  }));
  const { isActive: customIsActive, editorOptions } = configs;
  const isActive = customIsActive === void 0 ? isActiveNode : customIsActive;
  const editor = useEditor(__spreadProps(__spreadValues({}, editorOptions), {
    content: text,
    editable: false
  }));
  const [isEditable, setIsEditable] = useState(false);
  const editingTextRef = useRef();
  const savedTextRef = useRef(text);
  useEffect(() => {
    if (!editor)
      return;
    editor.on("update", ({ editor: editor2 }) => {
      editingTextRef.current = editor2.getHTML();
    });
  }, [editor]);
  useEffect(() => {
    if (!isActive) {
      setIsEditable(false);
    }
  }, [isActive]);
  useEffect(() => {
    if (!editor)
      return;
    const { isEditable: isEditable2, isFocused, commands } = editor;
    if (isEditable2 && !isFocused) {
      commands.focus("end");
    }
  }, [editor == null ? void 0 : editor.isEditable]);
  useEffect(() => {
    if (!editor)
      return;
    editor.setEditable(isEditable);
    setIsEditingText(isEditable);
    if (isEditable) {
      const { state } = editor;
      const noHistoryEvents = undoDepth(state) === 0 && redoDepth(state) === 0;
      if (!noHistoryEvents) {
        editor.chain().setContent(editor.getHTML(), false, {
          preserveWhitespace: "full"
        }).setMeta(ADD_TO_HISTORY_KEY, false).run();
      }
    }
  }, [editor, isEditable]);
  useEffect(() => {
    if (!editor)
      return;
    if (isEditable) {
      const handleClickOutsideBuilder = () => {
        setIsEditable(false);
        const editorText = editingTextRef.current;
        if (editorText !== savedTextRef.current) {
          setText(editorText);
        }
      };
      document.addEventListener("mousedown", handleClickOutsideBuilder);
      return () => {
        document.removeEventListener("mousedown", handleClickOutsideBuilder);
      };
    } else {
      const editorText = editor.getHTML();
      if (text !== editorText) {
        setText(editorText);
      }
    }
  }, [editor, isEditable]);
  useEffect(() => {
    savedTextRef.current = text;
    if (editor && !isEditable && editor.getHTML() !== text) {
      editor.chain().setContent(text, false, {
        preserveWhitespace: "full"
      }).setMeta(ADD_TO_HISTORY_KEY, false).blur().run();
    }
  }, [text]);
  return { editor, isEditable, setIsEditable };
};

export { useCustomTiptap };
