'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var styled = require('@emotion/styled');
var coreEditor = require('@tempi/core-editor');
var coreRenderer = require('@tempi/core-renderer');
var antd = require('antd');
var set = require('lodash.set');
var React = require('react');
var constants = require('./constants.js');
var quickSetting = require('./quick-setting.js');
var setting = require('./setting.js');
var styleSetting = require('./style-setting.js');
var ui = require('./ui.js');
var utils = require('./utils.js');
var reactIcons = require('@fluentui/react-icons');
var selector$2 = require('../global-block/selector.js');
var selector$3 = require('../websitefooter/selector.js');
var propKey = require('../../constants/propKey.js');
var Col = require('../../core/Grid/Col.js');
var selector = require('../section/selector.js');
var selector$1 = require('../root/selector.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);
var set__default = /*#__PURE__*/_interopDefaultLegacy(set);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const { useToken } = antd.theme;
const Empty = styled__default["default"].div`
  min-height: 160px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;

  &::before {
    content: '';
    border: 1px dashed #d4d4d4;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    position: absolute;
  }
`;
const ColEditor = (props) => {
  var _b, _c, _d, _e;
  const { draggingNode, setOpenElementMenu } = coreEditor.useBuilder();
  const { token: themeToken } = useToken();
  const defaultPlaceholder = /* @__PURE__ */ jsxRuntime.jsx(reactIcons.AddCircleFilled, {
    style: {
      fontSize: 24,
      color: themeToken.colorPrimary,
      cursor: "pointer"
    },
    onClick: (e) => {
      e.stopPropagation();
      setOpenElementMenu(true);
    }
  });
  const _a = props, {
    children,
    commonStyle,
    placeholder = defaultPlaceholder
  } = _a, rest = __objRest(_a, [
    "children",
    "commonStyle",
    "placeholder"
  ]);
  const {
    enabled,
    query,
    actions,
    hoveredNodes,
    getSiblings,
    getNextNode,
    getPrevNode,
    getParent
  } = coreEditor.useEditor((state) => ({
    enabled: state.options.enabled,
    hoveredNodes: state.events.hovered
  }));
  const colRef = React.useRef(null);
  const {
    connectors: { connect },
    isActive,
    isHover,
    id,
    allDescendants
  } = coreEditor.useNode((node) => {
    return {
      isActive: node.events.selected,
      isHover: node.events.hovered,
      allDescendants: query.node(node.id).descendants(true)
    };
  });
  const colHovered = allDescendants.some((el) => hoveredNodes.has(el)) || isHover;
  const parent = getParent(id);
  const siblings = getSiblings(id);
  const adjacentSibling = React.useMemo(() => {
    return getNextNode(id) || getPrevNode(id);
  }, [id, siblings.length]);
  const grandParent = parent && query.node(parent.data.parent).get();
  const canDropSection = [parent == null ? void 0 : parent.id, grandParent == null ? void 0 : grandParent.id].includes(coreRenderer.ROOT);
  const siblingMd = utils.parseFlex((_d = (_c = (_b = adjacentSibling == null ? void 0 : adjacentSibling.data) == null ? void 0 : _b.props) == null ? void 0 : _c.md) == null ? void 0 : _d.flex);
  const [md, setMd] = coreEditor.useProp(propKey.PROP_KEY.Md);
  const nodeFlex = utils.parseFlex(md);
  const isColEmpty = !children && enabled;
  const { pos, newPos, isDragging } = utils.useDragging();
  const colWidth = (_e = colRef.current) == null ? void 0 : _e.offsetWidth;
  const stepPercent = utils.getStepPercent(
    pos,
    newPos,
    colWidth,
    nodeFlex,
    siblingMd
  );
  React.useEffect(() => {
    if (isDragging) {
      document.body.style.cursor = "col-resize";
    } else {
      document.body.style.cursor = "unset";
    }
    if (!isDragging && stepPercent) {
      setMd(`${Col.floorPercentage(nodeFlex + stepPercent)}%`);
      if (adjacentSibling) {
        const adjacentSiblingId = adjacentSibling.id;
        const otherSiblingsPercent = siblings.filter((nodeId) => nodeId !== adjacentSiblingId && nodeId !== id).map((id2) => {
          var _a2, _b2, _c2;
          return (_c2 = (_b2 = (_a2 = query.node(id2).get().data) == null ? void 0 : _a2.props) == null ? void 0 : _b2.md) == null ? void 0 : _c2.flex;
        });
        const remainingPercent = utils.getRemainingPercent(otherSiblingsPercent);
        actions.history.throttle().setProp(adjacentSiblingId, (props2) => {
          set__default["default"](
            props2,
            propKey.PROP_KEY.Md,
            `${Col.floorPercentage(remainingPercent - nodeFlex - stepPercent)}%`
          );
        });
      }
    }
  }, [isDragging]);
  const showBorderCanDrop = React.useMemo(() => {
    var _a2, _b2;
    if (!draggingNode)
      return false;
    if (isColEmpty)
      return false;
    if (((_a2 = draggingNode == null ? void 0 : draggingNode.data) == null ? void 0 : _a2.name) !== "RowEditor")
      return true;
    if (((_b2 = draggingNode == null ? void 0 : draggingNode.data) == null ? void 0 : _b2.name) === "RowEditor" && canDropSection)
      return true;
    return false;
  }, [draggingNode, isColEmpty, canDropSection]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.PbCol, __spreadProps(__spreadValues({
    commonStyle,
    ref: (ref) => {
      colRef.current = ref;
      connect(ref);
    }
  }, rest), {
    style: __spreadValues(__spreadValues({
      position: "relative"
    }, isActive && {
      boxShadow: `#ffa500 0px 0px 0px 2px`,
      zIndex: 999
    }), !isActive && (showBorderCanDrop || colHovered) && {
      boxShadow: `#ffa500 0px 0px 0px 1px`
    }),
    event: null,
    children: [
      (isActive || colHovered) && /* @__PURE__ */ jsxRuntime.jsx(quickSetting.ColQuickSetting, {}),
      !isColEmpty ? children : /* @__PURE__ */ jsxRuntime.jsx(Empty, {
        style: {
          minHeight: commonStyle == null ? void 0 : commonStyle.minHeight
        },
        children: /* @__PURE__ */ jsxRuntime.jsx("div", {
          style: { zIndex: 1 },
          children: placeholder
        })
      })
    ]
  }));
};
ColEditor.craft = coreEditor.crafting({
  displayName: "C\u1ED9t",
  tag: ui.PbCol.displayName.toLowerCase(),
  props: constants.DEFAULT_COL,
  rules: {
    canMoveIn: (incomingNodes, self, helper) => {
      const ancestors = helper(self.id).ancestors();
      if (incomingNodes.length === 1 && (incomingNodes == null ? void 0 : incomingNodes[0].data.name) === coreEditor.getEditorName({ RowEditor: selector.RowEditor })) {
        return ancestors.some(
          (nodeId) => {
            var _a, _b, _c, _d;
            return ((_d = (_c = (_b = (_a = helper(nodeId)) == null ? void 0 : _a.get) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.data) == null ? void 0 : _d.name) === coreEditor.getEditorName({ RootEditor: selector$1.RootEditor });
          }
        );
      } else {
        return incomingNodes.every(
          (incomingNode) => incomingNode.data.name !== coreEditor.getEditorName({ ColEditor })
        );
      }
    },
    canDrop: (targetNode) => {
      const allowTargets = [
        coreEditor.getEditorName({ RowEditor: selector.RowEditor }),
        coreEditor.getEditorName({ GlobalBlockEditor: selector$2.GlobalBlockEditor }),
        coreEditor.getEditorName({ WebsiteFooterEditor: selector$3.WebsiteFooterEditor })
      ];
      return allowTargets.includes(targetNode.data.name);
    }
  },
  effectAttributes: coreEditor.EffectAttributes,
  advanceAttributes: coreEditor.AdvanceAttributes,
  customAttributes: setting.ColSetting,
  commonAttributes: styleSetting.ColStyle
});

exports.ColEditor = ColEditor;
