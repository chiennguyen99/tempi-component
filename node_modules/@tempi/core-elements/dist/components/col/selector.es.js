import { jsx, jsxs } from 'react/jsx-runtime';
import styled from '@emotion/styled';
import { useBuilder, useEditor, useNode, useProp, crafting, getEditorName, EffectAttributes, AdvanceAttributes } from '@tempi/core-editor';
import { ROOT } from '@tempi/core-renderer';
import { theme } from 'antd';
import set from 'lodash.set';
import { useRef, useMemo, useEffect } from 'react';
import { DEFAULT_COL } from './constants.es.js';
import { ColQuickSetting } from './quick-setting.es.js';
import { ColSetting } from './setting.es.js';
import { ColStyle } from './style-setting.es.js';
import { PbCol } from './ui.es.js';
import { parseFlex, useDragging, getStepPercent, getRemainingPercent } from './utils.es.js';
import { AddCircleFilled } from '@fluentui/react-icons';
import { GlobalBlockEditor } from '../global-block/selector.es.js';
import { WebsiteFooterEditor } from '../websitefooter/selector.es.js';
import { PROP_KEY } from '../../constants/propKey.es.js';
import { floorPercentage } from '../../core/Grid/Col.es.js';
import { RowEditor } from '../section/selector.es.js';
import { RootEditor } from '../root/selector.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const { useToken } = theme;
const Empty = styled.div`
  min-height: 160px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;

  &::before {
    content: '';
    border: 1px dashed #d4d4d4;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    position: absolute;
  }
`;
const ColEditor = (props) => {
  var _b, _c, _d, _e;
  const { draggingNode, setOpenElementMenu } = useBuilder();
  const { token: themeToken } = useToken();
  const defaultPlaceholder = /* @__PURE__ */ jsx(AddCircleFilled, {
    style: {
      fontSize: 24,
      color: themeToken.colorPrimary,
      cursor: "pointer"
    },
    onClick: (e) => {
      e.stopPropagation();
      setOpenElementMenu(true);
    }
  });
  const _a = props, {
    children,
    commonStyle,
    placeholder = defaultPlaceholder
  } = _a, rest = __objRest(_a, [
    "children",
    "commonStyle",
    "placeholder"
  ]);
  const {
    enabled,
    query,
    actions,
    hoveredNodes,
    getSiblings,
    getNextNode,
    getPrevNode,
    getParent
  } = useEditor((state) => ({
    enabled: state.options.enabled,
    hoveredNodes: state.events.hovered
  }));
  const colRef = useRef(null);
  const {
    connectors: { connect },
    isActive,
    isHover,
    id,
    allDescendants
  } = useNode((node) => {
    return {
      isActive: node.events.selected,
      isHover: node.events.hovered,
      allDescendants: query.node(node.id).descendants(true)
    };
  });
  const colHovered = allDescendants.some((el) => hoveredNodes.has(el)) || isHover;
  const parent = getParent(id);
  const siblings = getSiblings(id);
  const adjacentSibling = useMemo(() => {
    return getNextNode(id) || getPrevNode(id);
  }, [id, siblings.length]);
  const grandParent = parent && query.node(parent.data.parent).get();
  const canDropSection = [parent == null ? void 0 : parent.id, grandParent == null ? void 0 : grandParent.id].includes(ROOT);
  const siblingMd = parseFlex((_d = (_c = (_b = adjacentSibling == null ? void 0 : adjacentSibling.data) == null ? void 0 : _b.props) == null ? void 0 : _c.md) == null ? void 0 : _d.flex);
  const [md, setMd] = useProp(PROP_KEY.Md);
  const nodeFlex = parseFlex(md);
  const isColEmpty = !children && enabled;
  const { pos, newPos, isDragging } = useDragging();
  const colWidth = (_e = colRef.current) == null ? void 0 : _e.offsetWidth;
  const stepPercent = getStepPercent(
    pos,
    newPos,
    colWidth,
    nodeFlex,
    siblingMd
  );
  useEffect(() => {
    if (isDragging) {
      document.body.style.cursor = "col-resize";
    } else {
      document.body.style.cursor = "unset";
    }
    if (!isDragging && stepPercent) {
      setMd(`${floorPercentage(nodeFlex + stepPercent)}%`);
      if (adjacentSibling) {
        const adjacentSiblingId = adjacentSibling.id;
        const otherSiblingsPercent = siblings.filter((nodeId) => nodeId !== adjacentSiblingId && nodeId !== id).map((id2) => {
          var _a2, _b2, _c2;
          return (_c2 = (_b2 = (_a2 = query.node(id2).get().data) == null ? void 0 : _a2.props) == null ? void 0 : _b2.md) == null ? void 0 : _c2.flex;
        });
        const remainingPercent = getRemainingPercent(otherSiblingsPercent);
        actions.history.throttle().setProp(adjacentSiblingId, (props2) => {
          set(
            props2,
            PROP_KEY.Md,
            `${floorPercentage(remainingPercent - nodeFlex - stepPercent)}%`
          );
        });
      }
    }
  }, [isDragging]);
  const showBorderCanDrop = useMemo(() => {
    var _a2, _b2;
    if (!draggingNode)
      return false;
    if (isColEmpty)
      return false;
    if (((_a2 = draggingNode == null ? void 0 : draggingNode.data) == null ? void 0 : _a2.name) !== "RowEditor")
      return true;
    if (((_b2 = draggingNode == null ? void 0 : draggingNode.data) == null ? void 0 : _b2.name) === "RowEditor" && canDropSection)
      return true;
    return false;
  }, [draggingNode, isColEmpty, canDropSection]);
  return /* @__PURE__ */ jsxs(PbCol, __spreadProps(__spreadValues({
    commonStyle,
    ref: (ref) => {
      colRef.current = ref;
      connect(ref);
    }
  }, rest), {
    style: __spreadValues(__spreadValues({
      position: "relative"
    }, isActive && {
      boxShadow: `#ffa500 0px 0px 0px 2px`,
      zIndex: 999
    }), !isActive && (showBorderCanDrop || colHovered) && {
      boxShadow: `#ffa500 0px 0px 0px 1px`
    }),
    event: null,
    children: [
      (isActive || colHovered) && /* @__PURE__ */ jsx(ColQuickSetting, {}),
      !isColEmpty ? children : /* @__PURE__ */ jsx(Empty, {
        style: {
          minHeight: commonStyle == null ? void 0 : commonStyle.minHeight
        },
        children: /* @__PURE__ */ jsx("div", {
          style: { zIndex: 1 },
          children: placeholder
        })
      })
    ]
  }));
};
ColEditor.craft = crafting({
  displayName: "C\u1ED9t",
  tag: PbCol.displayName.toLowerCase(),
  props: DEFAULT_COL,
  rules: {
    canMoveIn: (incomingNodes, self, helper) => {
      const ancestors = helper(self.id).ancestors();
      if (incomingNodes.length === 1 && (incomingNodes == null ? void 0 : incomingNodes[0].data.name) === getEditorName({ RowEditor })) {
        return ancestors.some(
          (nodeId) => {
            var _a, _b, _c, _d;
            return ((_d = (_c = (_b = (_a = helper(nodeId)) == null ? void 0 : _a.get) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.data) == null ? void 0 : _d.name) === getEditorName({ RootEditor });
          }
        );
      } else {
        return incomingNodes.every(
          (incomingNode) => incomingNode.data.name !== getEditorName({ ColEditor })
        );
      }
    },
    canDrop: (targetNode) => {
      const allowTargets = [
        getEditorName({ RowEditor }),
        getEditorName({ GlobalBlockEditor }),
        getEditorName({ WebsiteFooterEditor })
      ];
      return allowTargets.includes(targetNode.data.name);
    }
  },
  effectAttributes: EffectAttributes,
  advanceAttributes: AdvanceAttributes,
  customAttributes: ColSetting,
  commonAttributes: ColStyle
});

export { ColEditor };
