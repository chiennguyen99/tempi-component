'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var coreRenderer = require('@tempi/core-renderer');
var Col = require('../../core/Grid/Col.js');

const useDragging = () => {
  const [isDragging, setIsDragging] = React.useState(false);
  const [pos, setPos] = React.useState(0);
  const [newPos, setNewPos] = React.useState(0);
  const ref = React.useRef(null);
  const current = ref == null ? void 0 : ref.current;
  const onMouseMove = (e) => {
    if (!isDragging)
      return;
    setNewPos(e.x - (current == null ? void 0 : current.offsetWidth) / 2);
    e.stopPropagation();
    e.preventDefault();
  };
  const onMouseUp = (e) => {
    document.querySelector(
      `#${coreRenderer.TEMPI_MAIN_IFRAME}`
    ).style.pointerEvents = "auto";
    setIsDragging(false);
    e.stopPropagation();
    e.preventDefault();
  };
  const onMouseDown = (e) => {
    document.querySelector(
      `#${coreRenderer.TEMPI_MAIN_IFRAME}`
    ).style.pointerEvents = "none";
    if (e.button !== 0)
      return;
    setIsDragging(true);
    setPos(e.x - (current == null ? void 0 : current.offsetWidth) / 2);
    setNewPos(e.x - (current == null ? void 0 : current.offsetWidth) / 2);
    e.stopPropagation();
    e.preventDefault();
  };
  React.useEffect(() => {
    current == null ? void 0 : current.addEventListener("mousedown", onMouseDown);
    return () => {
      current == null ? void 0 : current.removeEventListener("mousedown", onMouseDown);
    };
  }, [current]);
  React.useEffect(() => {
    if (isDragging) {
      document.addEventListener("mouseup", onMouseUp);
      document.addEventListener("mousemove", onMouseMove);
    } else {
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);
    }
    return () => {
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);
    };
  }, [isDragging]);
  return { ref, pos, newPos, isDragging };
};
const MIN_PERCENTAGE_COL_WIDTH = 8;
const getStepPercent = (pos, newPos, colWidth, colFlex, siblingFlex) => {
  let step = Col.floorPercentage(Math.abs(newPos - pos) / (colWidth / colFlex));
  if (newPos < pos) {
    if (colFlex - step < MIN_PERCENTAGE_COL_WIDTH)
      step = colFlex - MIN_PERCENTAGE_COL_WIDTH;
    step = -step;
  } else {
    if (siblingFlex - step < MIN_PERCENTAGE_COL_WIDTH)
      step = siblingFlex - MIN_PERCENTAGE_COL_WIDTH;
  }
  return step;
};
const parseFlex = (flex) => {
  return parseFloat(flex == null ? void 0 : flex.replace("%", ""));
};
const getRemainingPercent = (percents) => {
  const remainingPercent = Col.floorPercentage(
    percents.reduce((flex, percent) => {
      return flex -= parseFlex(percent) || 0;
    }, 100)
  );
  return remainingPercent;
};
const getColWidthProps = (md) => {
  return {
    md: {
      flex: Col.percentage(md, 12)
    },
    xs: {
      flex: "100%"
    }
  };
};
const parseFlexPercent = (value) => {
  try {
    if (typeof value !== "string")
      return 100;
    const flex = value.replace("%", "");
    if (isNaN(+flex))
      return 100;
    return +flex;
  } catch (e) {
    console.warn(e);
    return 100;
  }
};

exports.MIN_PERCENTAGE_COL_WIDTH = MIN_PERCENTAGE_COL_WIDTH;
exports.getColWidthProps = getColWidthProps;
exports.getRemainingPercent = getRemainingPercent;
exports.getStepPercent = getStepPercent;
exports.parseFlex = parseFlex;
exports.parseFlexPercent = parseFlexPercent;
exports.useDragging = useDragging;
