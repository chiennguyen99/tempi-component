import { useState, useRef, useEffect } from 'react';
import { TEMPI_MAIN_IFRAME } from '@tempi/core-renderer';
import { percentage, floorPercentage } from '../../core/Grid/Col.es.js';

const useDragging = () => {
  const [isDragging, setIsDragging] = useState(false);
  const [pos, setPos] = useState(0);
  const [newPos, setNewPos] = useState(0);
  const ref = useRef(null);
  const current = ref == null ? void 0 : ref.current;
  const onMouseMove = (e) => {
    if (!isDragging)
      return;
    setNewPos(e.x - (current == null ? void 0 : current.offsetWidth) / 2);
    e.stopPropagation();
    e.preventDefault();
  };
  const onMouseUp = (e) => {
    document.querySelector(
      `#${TEMPI_MAIN_IFRAME}`
    ).style.pointerEvents = "auto";
    setIsDragging(false);
    e.stopPropagation();
    e.preventDefault();
  };
  const onMouseDown = (e) => {
    document.querySelector(
      `#${TEMPI_MAIN_IFRAME}`
    ).style.pointerEvents = "none";
    if (e.button !== 0)
      return;
    setIsDragging(true);
    setPos(e.x - (current == null ? void 0 : current.offsetWidth) / 2);
    setNewPos(e.x - (current == null ? void 0 : current.offsetWidth) / 2);
    e.stopPropagation();
    e.preventDefault();
  };
  useEffect(() => {
    current == null ? void 0 : current.addEventListener("mousedown", onMouseDown);
    return () => {
      current == null ? void 0 : current.removeEventListener("mousedown", onMouseDown);
    };
  }, [current]);
  useEffect(() => {
    if (isDragging) {
      document.addEventListener("mouseup", onMouseUp);
      document.addEventListener("mousemove", onMouseMove);
    } else {
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);
    }
    return () => {
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);
    };
  }, [isDragging]);
  return { ref, pos, newPos, isDragging };
};
const MIN_PERCENTAGE_COL_WIDTH = 8;
const getStepPercent = (pos, newPos, colWidth, colFlex, siblingFlex) => {
  let step = floorPercentage(Math.abs(newPos - pos) / (colWidth / colFlex));
  if (newPos < pos) {
    if (colFlex - step < MIN_PERCENTAGE_COL_WIDTH)
      step = colFlex - MIN_PERCENTAGE_COL_WIDTH;
    step = -step;
  } else {
    if (siblingFlex - step < MIN_PERCENTAGE_COL_WIDTH)
      step = siblingFlex - MIN_PERCENTAGE_COL_WIDTH;
  }
  return step;
};
const parseFlex = (flex) => {
  return parseFloat(flex == null ? void 0 : flex.replace("%", ""));
};
const getRemainingPercent = (percents) => {
  const remainingPercent = floorPercentage(
    percents.reduce((flex, percent) => {
      return flex -= parseFlex(percent) || 0;
    }, 100)
  );
  return remainingPercent;
};
const getColWidthProps = (md) => {
  return {
    md: {
      flex: percentage(md, 12)
    },
    xs: {
      flex: "100%"
    }
  };
};
const parseFlexPercent = (value) => {
  try {
    if (typeof value !== "string")
      return 100;
    const flex = value.replace("%", "");
    if (isNaN(+flex))
      return 100;
    return +flex;
  } catch (e) {
    console.warn(e);
    return 100;
  }
};

export { MIN_PERCENTAGE_COL_WIDTH, getColWidthProps, getRemainingPercent, getStepPercent, parseFlex, parseFlexPercent, useDragging };
