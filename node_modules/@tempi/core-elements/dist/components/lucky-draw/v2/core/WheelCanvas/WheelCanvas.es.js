import { jsx } from 'react/jsx-runtime';
import { getImageUrlFromGoogleUserContent } from '@tempi/core-renderer';
import { createRef, useEffect } from 'react';
import { LUCKY_DRAW_DEFAULT_COLOR } from '../../constants.es.js';
import { calculateImageSize, clamp } from '../utils.es.js';
import { WheelCanvasStyle } from './styles.es.js';

const getImage = async (url) => new Promise(function(resolve) {
  const img = new Image();
  img.onload = function() {
    resolve(img);
  };
  img.src = url;
});
const drawWheel = async (canvasRef, items, config) => {
  var _a, _b, _c, _d;
  const QUANTITY = items.length;
  let {
    innerRadius,
    radiusLineColor,
    radiusLineWidth,
    fontSize,
    perpendicularPrize,
    textDistance,
    background
  } = config;
  fontSize *= 2;
  const canvas = canvasRef.current;
  if (canvas == null ? void 0 : canvas.getContext("2d")) {
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, 500, 500);
    ctx.strokeStyle = "transparent";
    ctx.lineWidth = 0;
    const arc = Math.PI / (QUANTITY / 2);
    const startAngle = 0;
    const outsideRadius = canvas.width / 2 - 10;
    const clampedTextDistance = clamp(0, 100, textDistance);
    const textRadius = outsideRadius * clampedTextDistance / 100;
    const clampedInsideRadius = clamp(0, 100, innerRadius);
    const insideRadius = outsideRadius * clampedInsideRadius / 100;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const DEFAULT_PRIZE_IMAGE_WIDTH = 150;
    ctx.font = `bold ${fontSize}px Helvetica, Arial`;
    ctx.beginPath();
    ctx.arc(centerX, centerY, canvas.width / 2 - 32, 0, 360, false);
    ctx.fillStyle = "#ff6666";
    ctx.fill();
    if ((_a = background == null ? void 0 : background.image) == null ? void 0 : _a.src) {
      const bgImage = await getImage(
        getImageUrlFromGoogleUserContent(
          background.image.src,
          background.image.googleImageParams
        )
      );
      const isRotate = (background == null ? void 0 : background.rotate) !== null;
      const size = calculateImageSize(
        bgImage.width,
        bgImage.height,
        null,
        canvas.width
      );
      ctx.translate(centerX, centerY);
      if (isRotate) {
        ctx.rotate(background.rotate * Math.PI / 180);
      }
      ctx.drawImage(
        bgImage,
        -size.width / 2,
        -size.height / 2,
        size.width,
        size.height
      );
      if (isRotate) {
        ctx.rotate(-(background.rotate * Math.PI) / 180);
      }
      ctx.translate(-centerX, -centerY);
    }
    const isImageBackground = !!((_b = background == null ? void 0 : background.image) == null ? void 0 : _b.src);
    for (let i = 0; i < items.length; i++) {
      const angle = startAngle + i * arc;
      const { style } = items[i];
      ctx.fillStyle = (style == null ? void 0 : style.backgroundColor) || LUCKY_DRAW_DEFAULT_COLOR;
      if (!isImageBackground) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, outsideRadius, angle, angle + arc, false);
        ctx.arc(centerX, centerY, insideRadius, angle + arc, angle, true);
        ctx.stroke();
        ctx.fill();
      }
      ctx.save();
      if (!isImageBackground) {
        ctx.strokeStyle = radiusLineWidth <= 0 ? "transparent" : radiusLineColor;
        ctx.lineWidth = radiusLineWidth;
        for (let j = 0; j < items.length; j++) {
          const radiusAngle = startAngle + j * arc;
          ctx.beginPath();
          ctx.moveTo(
            centerX + (insideRadius + 1) * Math.cos(radiusAngle),
            centerY + (insideRadius + 1) * Math.sin(radiusAngle)
          );
          ctx.lineTo(
            centerX + (outsideRadius - 1) * Math.cos(radiusAngle),
            centerY + (outsideRadius - 1) * Math.sin(radiusAngle)
          );
          ctx.closePath();
          ctx.stroke();
        }
      }
      ctx.fillStyle = style && style.textColor;
      ctx.translate(
        centerX + Math.cos(angle + arc / 2) * textRadius,
        centerY + Math.sin(angle + arc / 2) * textRadius
      );
      const text = items[i].name;
      const imgSrc = (_c = items[i].image) == null ? void 0 : _c.src;
      const imgWidth = (_d = items[i].image) == null ? void 0 : _d.width;
      const textRotationAngle = perpendicularPrize ? angle + arc / 2 + Math.PI / 2 : angle + arc / 2;
      ctx.rotate(textRotationAngle);
      if (imgSrc) {
        const img = new Image();
        img.src = imgSrc;
        img.onload = function() {
          const { width, height } = calculateImageSize(
            img.width,
            img.height,
            imgWidth,
            DEFAULT_PRIZE_IMAGE_WIDTH
          );
          const x = centerX + Math.cos(angle + arc / 2) * textRadius;
          const y = centerY + Math.sin(angle + arc / 2) * textRadius;
          ctx.translate(x, y);
          ctx.rotate(textRotationAngle);
          ctx.drawImage(img, -width / 2, -height / 2, width, height);
          ctx.rotate(-textRotationAngle);
          ctx.translate(-x, -y);
        };
      } else {
        ctx.fillText(text, -ctx.measureText(text).width / 2, fontSize / 2.7);
      }
      ctx.restore();
    }
  }
};
const redraw = (canvasRef, items, config) => {
  const canvas = canvasRef.current;
  if (canvas == null ? void 0 : canvas.getContext("2d")) {
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawWheel(canvasRef, items, config);
  }
};
const WheelCanvas = (props) => {
  const canvasRef = createRef();
  const {
    items,
    width,
    height,
    fontSize,
    innerRadius,
    perpendicularPrize,
    radiusLineColor,
    radiusLineWidth,
    textDistance,
    background,
    border
  } = props;
  useEffect(() => {
    drawWheel(canvasRef, items, props);
  }, [
    items,
    fontSize,
    border,
    innerRadius,
    perpendicularPrize,
    radiusLineColor,
    radiusLineWidth,
    textDistance,
    width,
    height
  ]);
  useEffect(() => {
    redraw(canvasRef, items, props);
  }, [background, items]);
  return /* @__PURE__ */ jsx(WheelCanvasStyle, {
    ref: canvasRef,
    width,
    height
  });
};
var WheelCanvas$1 = WheelCanvas;

export { WheelCanvas$1 as default };
