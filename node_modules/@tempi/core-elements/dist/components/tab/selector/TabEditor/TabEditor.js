'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var coreEditor = require('@tempi/core-editor');
var React = require('react');
var TabQuickSetting = require('./TabQuickSetting.js');
var TabSetting = require('./TabSetting.js');
var TabStyleSetting = require('./TabStyleSetting.js');
var Tab = require('../../ui/Tab/Tab.js');
var selector = require('../../../section/selector.js');
var selector$1 = require('../../../root/selector.js');

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const TabEditor = coreEditor.withSelector(
  (_a) => {
    var _b = _a, { children } = _b, rest = __objRest(_b, ["children"]);
    const {
      query: { node },
      actions
    } = coreEditor.useEditor();
    const { childNodes, id } = coreEditor.useNode((currentNode) => ({
      childNodes: currentNode.data.nodes.map(
        (childNodeId) => node(childNodeId).get()
      )
    }));
    const tabs = childNodes.map((node2) => {
      const nodeProps = node2.data.props;
      return {
        id: node2.id,
        title: nodeProps.title
      };
    });
    const reArrangeTabs = () => {
      rest.tabs.forEach((tab, index) => {
        if (node(id).isCanvas()) {
          actions.history.ignore().move(tab.id, id, index);
        }
      });
    };
    const updateTabsTitle = () => {
      const check = rest.tabs.some((tab, index) => {
        return tab.id === tabs[index].id && tab.title !== tabs[index].title;
      });
      if (check) {
        actions.history.ignore().setProp(id, (props) => {
          props.tabs = tabs;
        });
      }
    };
    React.useEffect(() => {
      var _a2;
      if (((_a2 = rest == null ? void 0 : rest.tabs) == null ? void 0 : _a2.length) === (tabs == null ? void 0 : tabs.length) && JSON.stringify(rest.tabs) !== JSON.stringify(tabs)) {
        reArrangeTabs();
      }
    }, [rest.tabs]);
    React.useEffect(() => {
      var _a2;
      if (((_a2 = rest == null ? void 0 : rest.tabs) == null ? void 0 : _a2.length) !== (tabs == null ? void 0 : tabs.length)) {
        actions.history.ignore().setProp(id, (props) => {
          props.tabs = tabs;
        });
      } else {
        updateTabsTitle();
      }
    }, [tabs]);
    return /* @__PURE__ */ jsxRuntime.jsx(Tab.Tab, __spreadProps(__spreadValues({}, rest), {
      children
    }));
  },
  {
    displayName: "Tab",
    tag: Tab.Tab.displayName.toLowerCase(),
    quickSetting: TabQuickSetting.TabQuickSetting,
    customAttributes: TabSetting.TabSetting,
    advanceAttributes: coreEditor.AdvanceAttributes,
    commonAttributes: TabStyleSetting.TabStyleSetting,
    rules: {
      canDrop: (targetNode) => {
        const ignoreTargets = [
          coreEditor.getEditorName({ RowEditor: selector.RowEditor }),
          coreEditor.getEditorName({ RootEditor: selector$1.RootEditor })
        ];
        return !ignoreTargets.includes(targetNode.data.name);
      }
    }
  }
);

exports.TabEditor = TabEditor;
