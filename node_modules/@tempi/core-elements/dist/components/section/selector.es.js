import { jsx, jsxs } from 'react/jsx-runtime';
import { useBuilder, useEditor, useNode, useProp, crafting, AdvanceAttributes, EffectAttributes, getEditorName } from '@tempi/core-editor';
import { ROOT, HEADER, FOOTER, COMPONENT_TAG } from '@tempi/core-renderer';
import set from 'lodash.set';
import { useEffect } from 'react';
import { WidthTypeEnum } from '../../types/index.es.js';
import { PbRow } from '../row/ui.es.js';
import { DEFAULT_SECTION } from './constant.es.js';
import { SectionQuickSetting } from './quick-setting.es.js';
import { PbSection } from './ui.es.js';
import { AddBlockButton } from '../../core/Indicator/AddBlockButton.es.js';
import { RowQuickSetting } from '../row/quick-setting.es.js';
import { PROP_KEY } from '../../constants/propKey.es.js';
import { DEFAULT_GUTTER, DEFAULT_WIDTH } from '../../constants/grid.es.js';
import { RenderFloatingQuickSetting } from '../../core/RenderFloatingQuickSetting/RenderFloatingQuickSetting.es.js';
import { RowSetting } from '../row/setting.es.js';
import { RowStyle } from '../row/style-setting.es.js';
import { ColEditor } from '../col/selector.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const RowEditor = (_a) => {
  var _b = _a, {
    commonStyle,
    children,
    addBlockButton: passingAddBlockButton = /* @__PURE__ */ jsx(AddBlockButton, {})
  } = _b, rest = __objRest(_b, [
    "commonStyle",
    "children",
    "addBlockButton"
  ]);
  const { isEditingBlock } = useBuilder();
  const addBlockButton = isEditingBlock ? null : passingAddBlockButton;
  const {
    actions,
    query: { node },
    hoveredNodes,
    resizeColumns
  } = useEditor((state) => ({
    hoveredNodes: state.events.hovered
  }));
  const {
    id,
    widthType,
    parent,
    isHover,
    connectors: { connect },
    childNodes,
    allDescendants,
    isActive,
    tag
  } = useNode(({ data, events, id: id2 }) => {
    var _a2, _b2;
    return {
      parent: data == null ? void 0 : data.parent,
      widthType: (_a2 = data == null ? void 0 : data.props) == null ? void 0 : _a2.widthType,
      isHover: events.hovered,
      allDescendants: node(id2).descendants(true),
      childNodes: data == null ? void 0 : data.nodes,
      isActive: events.selected,
      tag: (_b2 = data == null ? void 0 : data.custom) == null ? void 0 : _b2.tag
    };
  });
  const isSection = [ROOT, FOOTER].includes(parent);
  const [gutter, setGutter] = useProp(PROP_KEY.Gutter);
  const handleAutoResizeColumns = () => {
    const totalColWidth = childNodes.reduce((total, chilId) => {
      var _a2, _b2;
      const colWidth = parseFloat(((_b2 = (_a2 = node(chilId).get().data.props) == null ? void 0 : _a2.md) == null ? void 0 : _b2.flex) || 0);
      return total + colWidth;
    }, 0);
    if (totalColWidth > 100 || totalColWidth < 99)
      resizeColumns(id, childNodes.length);
  };
  useEffect(() => {
    handleAutoResizeColumns();
  }, [childNodes.length]);
  useEffect(() => {
    if (!gutter) {
      setGutter(DEFAULT_GUTTER);
    }
  }, [gutter, setGutter]);
  useEffect(() => {
    if (!widthType && [ROOT, HEADER, FOOTER].includes(parent)) {
      actions.history.ignore().setProp(id, (props) => {
        set(props, PROP_KEY.WidthType, WidthTypeEnum.full);
        set(props, PROP_KEY.ContentWidthType, WidthTypeEnum.fixed);
        set(props, PROP_KEY.ContentMaxWidthKey, DEFAULT_WIDTH);
      });
    }
  }, []);
  useEffect(() => {
    const handleUpdateTag = (tag2) => {
      actions.history.ignore().setCustom(id, (custom) => {
        custom.tag = tag2;
      });
    };
    if (isSection && tag !== COMPONENT_TAG.SECTION) {
      handleUpdateTag(COMPONENT_TAG.SECTION);
    } else if (!isSection && tag !== COMPONENT_TAG.ROW) {
      handleUpdateTag(COMPONENT_TAG.ROW);
    }
  }, [parent]);
  const hoveredChilds = allDescendants.some((el) => hoveredNodes.has(el));
  const showRowQuickSetting = hoveredChilds || isHover || isActive;
  if (isSection)
    return /* @__PURE__ */ jsx("div", {
      ref: connect,
      style: {
        width: "100%",
        position: "relative"
      },
      children: /* @__PURE__ */ jsxs(RenderFloatingQuickSetting, {
        quickSetting: /* @__PURE__ */ jsx(SectionQuickSetting, {}),
        children: [
          addBlockButton,
          /* @__PURE__ */ jsx(PbSection, __spreadProps(__spreadValues({
            commonStyle,
            gutter
          }, rest), {
            children
          }))
        ]
      })
    });
  return /* @__PURE__ */ jsxs(PbRow, __spreadProps(__spreadValues({
    ref: connect,
    commonStyle: __spreadProps(__spreadValues({}, commonStyle), { position: "relative" }),
    gutter
  }, rest), {
    children: [
      showRowQuickSetting && /* @__PURE__ */ jsx(RowQuickSetting, {}),
      children
    ]
  }));
};
RowEditor.craft = crafting({
  displayName: "H\xE0ng",
  tag: "row",
  props: DEFAULT_SECTION,
  advanceAttributes: AdvanceAttributes,
  customAttributes: RowSetting,
  commonAttributes: RowStyle,
  effectAttributes: EffectAttributes,
  rules: {
    canMoveIn: (incomingNodes) => {
      const allowSources = [getEditorName({ ColEditor })];
      return incomingNodes.every(
        (incomingNode) => allowSources.includes(incomingNode.data.name)
      );
    }
  }
});

export { RowEditor };
