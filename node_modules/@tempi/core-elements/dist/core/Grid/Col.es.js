import { jsx } from 'react/jsx-runtime';
import React__default from 'react';
import clsx from 'clsx';
import RowContext from './RowContext.es.js';
import { css } from '@emotion/react';
import styled from '@emotion/styled';
import { BREAK_POINTS, GRID_COLUMNS } from '../../constants/grid.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function parseFlex(flex) {
  if (typeof flex === "number") {
    return `${flex} ${flex} auto`;
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return `0 0 ${flex}`;
  }
  return flex;
}
const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
const Col = React__default.forwardRef(
  (props, ref) => {
    const { gutter, wrap } = React__default.useContext(RowContext);
    const _a = props, {
      span,
      order,
      offset,
      push,
      pull,
      className,
      children,
      flex,
      style
    } = _a, others = __objRest(_a, [
      "span",
      "order",
      "offset",
      "push",
      "pull",
      "className",
      "children",
      "flex",
      "style"
    ]);
    const prefixCls = "teko-col";
    let sizeClassObj = {};
    sizes.forEach((size) => {
      let sizeProps = {};
      const propSize = props[size];
      if (typeof propSize === "number") {
        sizeProps.span = propSize;
      } else if (typeof propSize === "object") {
        sizeProps = propSize || {};
      }
      sizeClassObj = __spreadProps(__spreadValues({}, sizeClassObj), {
        [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
        [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
        [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
        [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
        [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0
      });
    });
    const classes = clsx(
      prefixCls,
      {
        [`${prefixCls}-${span}`]: span !== void 0,
        [`${prefixCls}-order-${order}`]: order,
        [`${prefixCls}-offset-${offset}`]: offset,
        [`${prefixCls}-push-${push}`]: push,
        [`${prefixCls}-pull-${pull}`]: pull
      },
      className,
      sizeClassObj
    );
    let mergedStyle = __spreadValues({}, style);
    if (gutter) {
      mergedStyle = __spreadValues(__spreadValues({}, gutter[0] && gutter[0] > 0 ? {
        paddingLeft: gutter[0] / 2,
        paddingRight: gutter[0] / 2
      } : {}), mergedStyle);
    }
    if (flex) {
      mergedStyle.flex = parseFlex(flex);
      if (flex === "auto" && wrap === false && !mergedStyle.minWidth) {
        mergedStyle.minWidth = 0;
      }
    }
    return /* @__PURE__ */ jsx(StyledCol, __spreadProps(__spreadValues({}, others), {
      style: mergedStyle,
      className: classes,
      ref,
      children
    }));
  }
);
Col.displayName = "Col";
const floorPercentage = (percent) => {
  return Math.floor(percent * 100) / 100;
};
const percentage = (x, y) => {
  return floorPercentage(x / y * 100) + "%";
};
const loopGridColumn = (_class = "") => {
  let _css = `
    &.teko-col${_class}-0 {
      display: none;
    }
    &.teko-col-push-0 {
      left: auto;
    }
    &.teko-col-pull-0 {
      right: auto;
    }
    &.teko-col${_class}-push-0 {
      left: auto;
    }
    &.teko-col${_class}-pull-0 {
      right: auto;
    }
    &.teko-col${_class}-offset-0 {
      margin-left: 0;
    }
    &.teko-col${_class}-order-0 {
      order: 0;
    }
  `;
  for (let i = 1; i <= 24; i++) {
    _css += `
      &.teko-col${_class}-${i} {
        display: block;
        flex: 0 0 ${percentage(i, GRID_COLUMNS)};
        max-width: ${_class === "-lg" ? "84px" : ["-xl", "-xxl"].includes(_class) ? "104px" : percentage(i, GRID_COLUMNS)};
      }
      &.teko-col${_class}-push-${i} {
        left: ${percentage(i, GRID_COLUMNS)};
      }
      &.teko-col${_class}-pull-${i} {
        right: ${percentage(i, GRID_COLUMNS)};
      }
      &.teko-col${_class}-offset-${i} {
        margin-left: ${percentage(i, GRID_COLUMNS)};
      }
      &.teko-col${_class}-order-${i} {
        order: ${i};
      }
    `;
  }
  return _css;
};
const makeGrid = css`
  ${loopGridColumn()}
  ${loopGridColumn("-xs")}
  ${Object.keys(BREAK_POINTS).map(
  (label) => label !== "xs" ? `
    @media (min-width: ${BREAK_POINTS[label]}) {
      ${loopGridColumn(`-${label}`)}
    }
  ` : ""
).join("")}
`;
const flexStyle = (flex) => {
  if (!flex)
    return;
  return `
    flex: ${parseFlex(flex)};
    ${typeof flex === "string" ? `max-width: ${flex} !important;` : ""}
  `;
};
const makeFlexStyles = (props) => {
  var _a;
  return css`
    ${typeof props.xs === "object" && ((_a = props.xs) == null ? void 0 : _a.flex) !== void 0 ? flexStyle(props.xs.flex) : ""}
    ${Object.keys(BREAK_POINTS).map(
    (label) => {
      var _a2, _b;
      return ((_a2 = props[label]) == null ? void 0 : _a2.flex) && label !== "xs" ? `
      @media (min-width: ${BREAK_POINTS[label]}) {
        ${flexStyle((_b = props[label]) == null ? void 0 : _b.flex)};
      }
    ` : "";
    }
  ).join("")}
  `;
};
const StyledCol = styled.div(
  `
  &.teko-col {
    position: relative;
    max-width: 100%;
    // Prevent columns from collapsing when empty
    min-height: 1px;
  }`,
  makeGrid,
  makeFlexStyles
);

export { Col, floorPercentage, percentage };
