'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var styled = require('@emotion/styled');
var React = require('react');
var style = require('./style.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);

const NUMBER_REGEX = /^\d(\.\d+)*$/;
const EditableInput = ({
  value,
  onChange,
  min,
  max,
  precision
}) => {
  const [changingValue, setChangingValue] = React.useState();
  const valueString = Number(value).toString();
  const getIsFloatInput = () => {
    return precision !== void 0;
  };
  React.useEffect(() => {
    const parsedValue = getIsFloatInput() ? parseFloat(changingValue) : parseInt(changingValue);
    if (value !== parsedValue) {
      setChangingValue(valueString);
    }
  }, [value]);
  const handleChange = (e) => {
    var _a;
    let newValue = e.target.value;
    if (!newValue) {
      setChangingValue(newValue);
      return;
    }
    let parsedValue = parseInt(newValue);
    const numberArr = newValue.split(/(\.|,)/);
    if (numberArr.length > 1) {
      if (getIsFloatInput()) {
        const decimal = ((_a = numberArr[2]) == null ? void 0 : _a.substr(0, precision)) || "";
        newValue = `${numberArr[0]}.${decimal}`;
        parsedValue = parseFloat(newValue);
      } else {
        newValue = numberArr[0];
      }
    }
    if (parsedValue >= min && parsedValue <= max) {
      setChangingValue(newValue);
      if (value !== parsedValue) {
        onChange(parsedValue);
      }
    }
  };
  const handleBlur = () => {
    if (!NUMBER_REGEX.test(changingValue)) {
      setChangingValue(valueString);
    }
  };
  return /* @__PURE__ */ jsxRuntime.jsx(StyledInput, {
    value: changingValue || "",
    onChange: handleChange,
    onBlur: handleBlur
  });
};
const StyledInput = styled__default["default"].input(style.inputCss);

exports.EditableInput = EditableInput;
