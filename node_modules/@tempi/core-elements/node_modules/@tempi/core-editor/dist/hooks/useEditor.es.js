import { t } from '../i18n.es.js';
import { useEditor as useEditor$1 } from '@tempi/dnd-core';
import { ROOT, generateRandomId } from '@tempi/core-renderer';
import { floorPercentage, serializePB, clonePageContent, deserializePB } from '../utils/index.es.js';
import set from 'lodash.set';
import { message } from 'antd';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useEditor(collect) {
  const _a = useEditor$1(collect), { actions, query } = _a, collected = __objRest(_a, ["actions", "query"]);
  const resizeColumns = (rowId, nodesLength) => {
    const childNodes = query.node(rowId).childNodes();
    childNodes.forEach(
      (el) => actions.history.throttle().setProp(el, (props) => {
        set(props, "md.flex", `${floorPercentage(100 / nodesLength)}%`);
      })
    );
  };
  const generateId = (node) => {
    var _a2, _b;
    try {
      const isPopup = ((_b = (_a2 = node == null ? void 0 : node.data) == null ? void 0 : _a2.custom) == null ? void 0 : _b.tag) === "popupv1";
      let newNodeId = generateRandomId(10);
      const rootChildren = query.node("ROOT").childNodes();
      const mainPopupId = rootChildren.find(
        (id) => {
          var _a3, _b2, _c;
          return (_c = (_b2 = (_a3 = query.node(id)) == null ? void 0 : _a3.get().data) == null ? void 0 : _b2.props) == null ? void 0 : _c.isMainPopup;
        }
      );
      if (!isPopup || !mainPopupId)
        return newNodeId;
      if (mainPopupId.length >= newNodeId.length && mainPopupId >= newNodeId) {
        const base36NodeIds = Object.keys(JSON.parse(query.serialize())).map(
          (key) => parseInt(key.replaceAll(".", ""), 36)
        );
        const newNum = Math.max(...base36NodeIds) + 1;
        newNodeId = "." + newNum.toString(36);
      }
      return newNodeId;
    } catch (e) {
      return generateRandomId(10);
    }
  };
  const copyNode = (node, newId) => {
    const newNode = __spreadProps(__spreadValues({}, node), {
      id: newId,
      events: {
        dragged: false,
        hovered: false,
        selected: false
      }
    });
    return query.parseFreshNode(newNode).toNode();
  };
  const duplicateNode = async (node, parentId, index) => {
    if (!node || !parentId)
      return;
    const newId = generateId(node);
    const newNode = copyNode(node, newId);
    newNode.data.nodes = [];
    await actions.history.throttle().add(newNode, parentId, index);
    node.data.nodes.forEach((childNodeId) => {
      const childNode = query.node(childNodeId).get();
      const newChildNode = copyNode(childNode, generateId(childNode));
      duplicateNode(newChildNode, newId);
    });
  };
  const cloneNodeTree = (tree) => {
    const newNodes = {};
    const changeNodeId = (node, newParentId) => {
      const newNodeId = generateId(node);
      const childNodes = node.data.nodes.map(
        (childId) => changeNodeId(tree.nodes[childId], newNodeId)
      );
      const linkedNodes = Object.keys(node.data.linkedNodes).reduce(
        (acc, id) => {
          const newLinkedNodeId = changeNodeId(
            tree.nodes[node.data.linkedNodes[id]],
            newNodeId
          );
          return __spreadProps(__spreadValues({}, acc), {
            [id]: newLinkedNodeId
          });
        },
        {}
      );
      const tmpNode = __spreadProps(__spreadValues({}, node), {
        id: newNodeId,
        data: __spreadProps(__spreadValues({}, node.data), {
          parent: newParentId || node.data.parent,
          nodes: childNodes,
          linkedNodes
        })
      });
      const freshNode = query.parseFreshNode(tmpNode).toNode();
      newNodes[newNodeId] = freshNode;
      return newNodeId;
    };
    const rootNodeId = changeNodeId(tree.nodes[tree.rootNodeId]);
    return {
      rootNodeId,
      nodes: newNodes
    };
  };
  const addBlock = async (serializeNodes, index, parentId = ROOT, rootNodeId) => {
    const nodes = Object.entries(serializeNodes).map(
      ([key, el]) => query.parseSerializedNode(el).toNode((node) => node.id = key)
    );
    const nodeTree = {
      rootNodeId,
      nodes: nodes.reduce((acc, curr) => {
        acc[curr.id] = curr;
        return acc;
      }, {})
    };
    if (!rootNodeId) {
      const parent = nodes.find((el) => el.data.parent === ROOT);
      nodeTree.rootNodeId = parent == null ? void 0 : parent.id;
    }
    const newNodeTree = rootNodeId ? nodeTree : cloneNodeTree(nodeTree);
    if (index !== void 0) {
      actions.addNodeTree(newNodeTree, parentId, index);
    } else {
      actions.addNodeTree(newNodeTree, parentId);
    }
    return newNodeTree;
  };
  const onCopy = async (nodeId) => {
    try {
      const pageContent = serializePB(JSON.parse(query.serialize()), {
        isEditingBlock: false,
        isEditingPopup: false
      });
      const allDescendants = query.node(nodeId).descendants(true);
      const nodeTree = { rootNodeId: nodeId, [nodeId]: pageContent[nodeId] };
      allDescendants == null ? void 0 : allDescendants.forEach(
        (_id) => nodeTree[_id] = Object.assign({}, pageContent[_id])
      );
      await navigator.clipboard.writeText(JSON.stringify(nodeTree));
      message.success({ content: t("Sao ch\xE9p th\xE0nh c\xF4ng") });
    } catch (err) {
      message.error({ content: `${err.name}: ${err.message}.` });
    }
  };
  const onPaste = async (index, parentId, callbackTransformNestedContent) => {
    try {
      const serializePbNodeContent = await navigator.clipboard.readText();
      const clipboardData = JSON.parse(serializePbNodeContent);
      const _a2 = clipboardData, { rootNodeId } = _a2, nodeContent = __objRest(_a2, ["rootNodeId"]);
      const [copyContent, mappingOldNewKey] = clonePageContent(
        nodeContent,
        callbackTransformNestedContent,
        true
      );
      const insertNodes = deserializePB(copyContent);
      addBlock(
        insertNodes,
        index,
        parentId,
        mappingOldNewKey[rootNodeId]
      );
    } catch (e) {
    }
  };
  const getParent = (id) => {
    const node = query.node(id).get();
    if (!node)
      return;
    return node.data.parent && query.node(node.data.parent).get();
  };
  const getSiblings = (id) => {
    const parent = getParent(id);
    return parent && query.node(parent.id).descendants() || [];
  };
  const getNextNode = (id) => {
    const siblings = getSiblings(id);
    const index = siblings.findIndex((el) => el === id);
    return siblings[index + 1] && query.node(siblings[index + 1]).get();
  };
  const getPrevNode = (id) => {
    const siblings = getSiblings(id);
    const index = siblings.findIndex((el) => el === id);
    return siblings[index - 1] && query.node(siblings[index - 1]).get();
  };
  const getLastSection = (parentId = ROOT) => {
    const childNodes = query.node(parentId).childNodes().filter(
      (child) => {
        var _a2, _b, _c, _d;
        return ((_d = (_c = (_b = (_a2 = query.node(child)).get) == null ? void 0 : _b.call(_a2)) == null ? void 0 : _c.data) == null ? void 0 : _d.name) === "RowEditor";
      }
    );
    return childNodes[childNodes.length - 1];
  };
  return __spreadValues({
    actions,
    query,
    duplicateNode,
    addBlock,
    getSiblings,
    getNextNode,
    getPrevNode,
    getParent,
    resizeColumns,
    getLastSection,
    onCopy,
    onPaste
  }, collected);
}

export { useEditor };
