import { globalTracer, FORMAT_HTTP_HEADERS } from 'opentracing';
import { ApiError } from './error.es.js';
export { ApiError } from './error.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const normalizeSlashUrl = (baseURL = "", url) => {
  const normalizedBaseUrl = baseURL.endsWith("/") ? baseURL.slice(0, baseURL.length - 1) : baseURL;
  const normalizedPath = url.startsWith("/") ? url.slice(1) : url;
  return `${normalizedBaseUrl}/${normalizedPath}`;
};
const DEFAULT_ERROR_MESSAGE = "\u0110\xE3 c\xF3 l\u1ED7i x\u1EA3y ra, vui l\xF2ng th\u1EED l\u1EA1i sau!";
class Api {
  constructor(url, getError, defaultConfig = {}) {
    this.baseURL = url;
    this.interceptors = [];
    this.getError = getError;
    this.defaultConfig = defaultConfig;
  }
  _parseJson(response) {
    return response.text().then((text) => text ? JSON.parse(text) : null);
  }
  addInterceptor(interceptFn) {
    this.interceptors.push(interceptFn);
  }
  appendParamsToURL(url, params = {}) {
    if (params) {
      const paramsArr = [];
      for (const k of Object.keys(params)) {
        if (params[k] !== null && params[k] !== void 0) {
          paramsArr.push(`${k}=${encodeURIComponent(params[k])}`);
        }
      }
      if (paramsArr.length > 0)
        url = `${url}?${paramsArr.join("&")}`;
    }
    return url;
  }
  async request(path, body, method, config = {}) {
    var _a;
    const { params: configParams } = config;
    let headers = config.headers || {};
    const url = this.appendParamsToURL(path, configParams || {});
    let serializedBody = null;
    const isFormData = body && typeof body !== "string" && "append" in body;
    if (body) {
      if (typeof body !== "string") {
        if (isFormData) {
          serializedBody = new URLSearchParams(body).toString();
        } else {
          serializedBody = JSON.stringify(body);
          headers = __spreadValues({
            "Content-Type": "application/json"
          }, headers);
        }
      }
    }
    let serializedParams = null;
    if (configParams) {
      serializedParams = JSON.stringify(configParams);
    }
    const tracer = globalTracer();
    const spanName = `[${method}] ${normalizeSlashUrl(this.baseURL, path)}`;
    const span = tracer.startSpan(spanName);
    tracer.inject(span, FORMAT_HTTP_HEADERS, headers);
    span.setTag("http.method", method);
    span.setTag("http.baseurl", this.baseURL);
    span.log({
      body: serializedBody,
      params: serializedParams
    });
    const requestObj = __spreadProps(__spreadValues({}, this.defaultConfig), {
      method,
      headers: new Headers(headers),
      body: isFormData ? body : serializedBody
    });
    this.interceptors.forEach((fn) => fn(requestObj));
    const res = await fetch(
      url.startsWith("http") ? url : normalizeSlashUrl(this.baseURL, url),
      requestObj
    );
    if (res.status >= 400) {
      const resp = await res.json();
      const error = ((_a = this.getError) == null ? void 0 : _a.call(this, resp)) || new ApiError(DEFAULT_ERROR_MESSAGE, -1, resp);
      span.setTag("status", "error");
      span.log({
        error: JSON.stringify(error)
      });
      span.finish();
      return Promise.reject(error);
    }
    const respHeaders = {};
    res.headers.forEach((val, key) => respHeaders[key] = val);
    const data = await this._parseJson(res);
    span.setTag("status", "success");
    span.finish();
    return { code: res.status, data, headers: respHeaders };
  }
  async get(url, config = {}) {
    return await this.request(url, null, "GET", config);
  }
  async post(url, body, config = {}) {
    return await this.request(url, body, "POST", config);
  }
  async patch(url, body, config = {}) {
    return await this.request(url, body, "PATCH", config);
  }
  async put(url, body, config = {}) {
    return await this.request(url, body, "PUT", config);
  }
  async delete(url, body = {}, config = {}) {
    return await this.request(url, body, "DELETE", config);
  }
}

export { Api };
