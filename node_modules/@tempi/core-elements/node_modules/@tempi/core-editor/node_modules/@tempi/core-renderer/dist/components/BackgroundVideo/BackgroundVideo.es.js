import { jsx } from 'react/jsx-runtime';
import styled from '@emotion/styled';
import { useRef, useState, useEffect } from 'react';
import Ytb from 'react-youtube';
import { isGCSUrl } from '../../utils/isGCSUrl.es.js';
import { youtubeParser } from '../../utils/youtubeParser.es.js';
import { useIntersectionObserver } from '../../hooks/useIntersectionObserver.es.js';
import { getStyle } from '../../utils/transform.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const BackgroundVideo = ({
  src,
  uploadSrc,
  defaultOverlay,
  background,
  objectFit
}) => {
  const wrapperRef = useRef();
  const intervalRef = useRef();
  const [size, setSize] = useState();
  const getWidthHeightOfYtb = () => {
    if (!(wrapperRef == null ? void 0 : wrapperRef.current))
      return;
    let { clientWidth: width, clientHeight: height } = wrapperRef.current;
    const displayRatio = 16 / 9;
    const containerRatio = width / height;
    if (containerRatio < displayRatio) {
      width = height * displayRatio;
    } else if (containerRatio > displayRatio) {
      height = width / displayRatio;
    }
    return {
      width,
      height
    };
  };
  useEffect(() => {
    return () => clearTimeout(intervalRef.current);
  }, []);
  useEffect(() => {
    const resetWidthHeigthVideo = () => {
      const newSize = getWidthHeightOfYtb();
      if (newSize)
        setSize(newSize);
    };
    resetWidthHeigthVideo();
    window.addEventListener("resize", resetWidthHeigthVideo);
    return () => {
      window.removeEventListener("resize", resetWidthHeigthVideo);
    };
  }, [wrapperRef == null ? void 0 : wrapperRef.current]);
  const isIntersected = useIntersectionObserver(wrapperRef, {
    freezeOnceVisible: true
  });
  if (!src && !uploadSrc && !defaultOverlay)
    return null;
  const renderVideo = () => {
    if (!isIntersected || !wrapperRef.current)
      return null;
    if (isGCSUrl(uploadSrc)) {
      return /* @__PURE__ */ jsx("video", __spreadProps(__spreadValues({}, size), {
        style: __spreadProps(__spreadValues({}, videoStyle), {
          objectFit: objectFit || "fill"
        }),
        playsInline: true,
        loop: true,
        autoPlay: true,
        muted: true,
        src: uploadSrc
      }));
    }
    const videoId = youtubeParser(src);
    if (!videoId)
      return null;
    let videoPlayer;
    let totalVideoTime;
    const OVERHEAD = 10;
    const RESTART_BEFORE = 1e3;
    function checkVideoPos() {
      let currentTime = videoPlayer.getCurrentTime();
      currentTime = currentTime * 1e3;
      if (currentTime >= totalVideoTime) {
        videoPlayer.seekTo(0);
        intervalRef.current = setTimeout(checkVideoPos, totalVideoTime);
      } else {
        const newTime = totalVideoTime - currentTime - OVERHEAD;
        intervalRef.current = setTimeout(checkVideoPos, newTime);
      }
    }
    const onReady = (event) => {
      videoPlayer = event.target;
      totalVideoTime = videoPlayer.getDuration() * 1e3 - RESTART_BEFORE;
      intervalRef.current = setTimeout(checkVideoPos, totalVideoTime);
    };
    const onEnd = () => {
      clearTimeout(intervalRef.current);
    };
    return /* @__PURE__ */ jsx(StyledYtb, {
      videoId,
      opts: __spreadProps(__spreadValues({}, size), {
        playerVars: {
          playlist: videoId,
          playsInLine: 1,
          mute: 1,
          controls: 0,
          allowFullScreen: 1,
          autoplay: 1
        }
      }),
      onReady,
      onEnd
    });
  };
  return /* @__PURE__ */ jsx(Wrapper, {
    ref: wrapperRef,
    commonStyle: {
      defaultOverlay,
      background
    },
    children: renderVideo()
  });
};
const Wrapper = styled.div(
  ({ commonStyle }) => `
  ${getStyle(commonStyle)}

  position: absolute !important;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
  z-index: 0;
`
);
const StyledYtb = styled(Ytb)`
  iframe {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: -2; // z-index of overlay: -1
  }
`;
const videoStyle = {
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  zIndex: "-2"
};

export { BackgroundVideo };
