import { getImageUrlFromGoogleUserContent } from './image.es.js';
import { OverlayType, UnitEnum, ColorType, GradientType } from '../types/style.es.js';
import { BG_VISIBLE_LAZY_CLASS_NAME } from '../constants/common.es.js';
import { getRgbaFromHex } from './colors/util.es.js';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const isNumeric = (str) => {
  if (typeof str === "number")
    return true;
  if (typeof str !== "string")
    return false;
  return !isNaN(str) && !isNaN(parseFloat(str));
};
const jsToCss = (str) => str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
const getCommonCss = (attribute) => {
  return attribute && Object.entries(attribute).reduce((acc, curr) => {
    const [key, value] = curr;
    if ([null, void 0, false].some((el) => el === value) || /Unit$/.test(key))
      return acc;
    return `${acc}
${jsToCss(key)}: ${unitParse(
      value,
      attribute[`${key}Unit`]
    )};`;
  }, "");
};
const getFourSideCss = (props) => {
  const sidesOrder = ["top", "right", "bottom", "left"];
  const corderOrder = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
  return Object.entries(props).reduce((acc, curr) => {
    const [key, value = {}] = curr;
    const _a = value, { unit = UnitEnum.pixel } = _a, restValue = __objRest(_a, ["unit"]);
    return acc + "\n" + Object.keys(restValue).filter(
      (attr) => (sidesOrder.includes(attr) || corderOrder.includes(attr)) && value[attr] !== null && value[attr] !== void 0
    ).map((attr) => {
      let childValue;
      if (isNumeric(value[attr])) {
        childValue = value[attr] + unit;
      } else {
        childValue = value[attr];
      }
      return `${jsToCss(`${key}-${attr}`)}: ${childValue};`;
    }).join("\n");
  }, "");
};
const getBackgroundOverlay = (type, value) => {
  if (type === OverlayType.color && value) {
    return `
      & {
        position: relative;

        &:before {
          position: absolute;
          top: 0;
          bottom: 0;
          left: 0;
          right: 0;
          content: '';
          background: ${value};
          border-radius: inherit;
          z-index: -1;
        }
      }
    `;
  }
  return "";
};
const getBackgroundImageMarquee = (bgImgMarqueeDirection, bgImgMarqueeSpeed) => {
  if (!bgImgMarqueeDirection)
    return "";
  return `
    & {
      background-repeat: ${bgImgMarqueeDirection === "horizontal" ? "repeat-x" : "repeat-y"} !important;
      animation: ${bgImgMarqueeDirection === "horizontal" ? "bg-marquee-horizontal" : "bg-marquee-vertical"} ${99999 / (bgImgMarqueeSpeed || 30)}s linear infinite;
    }
  `;
};
const getBoxShadow = (shadow) => {
  let boxShadow = "";
  if (shadow == null ? void 0 : shadow.color) {
    boxShadow = "box-shadow: ";
    boxShadow += (shadow == null ? void 0 : shadow.x) ? `${shadow.x}px ` : "0 ";
    boxShadow += (shadow == null ? void 0 : shadow.y) ? `${shadow.y}px ` : "0 ";
    boxShadow += (shadow == null ? void 0 : shadow.blur) ? `${shadow.blur}px ` : "0 ";
    boxShadow += (shadow == null ? void 0 : shadow.spread) ? `${shadow.spread}px ` : "0 ";
    boxShadow += `${shadow.color};`;
  }
  if (shadow == null ? void 0 : shadow.on) {
    boxShadow = "box-shadow: ";
    boxShadow += (shadow == null ? void 0 : shadow.x) ? `${shadow.x}px ` : "0 ";
    boxShadow += (shadow == null ? void 0 : shadow.y) ? `${shadow.y}px ` : "0 ";
    boxShadow += (shadow == null ? void 0 : shadow.blur) ? `${shadow.blur}px ` : "0 ";
    boxShadow += (shadow == null ? void 0 : shadow.spread) ? `${shadow.spread}px ` : "0 ";
    boxShadow += `rgba(0,0,0,${shadow == null ? void 0 : shadow.opacity});`;
  }
  return boxShadow;
};
const getTextShadow = (shadow) => {
  let textShadow = "";
  if (shadow == null ? void 0 : shadow.color) {
    textShadow = "text-shadow: ";
    textShadow += (shadow == null ? void 0 : shadow.x) ? `${shadow.x}px ` : "0 ";
    textShadow += (shadow == null ? void 0 : shadow.y) ? `${shadow.y}px ` : "0 ";
    textShadow += (shadow == null ? void 0 : shadow.blur) ? `${shadow.blur}px ` : "0 ";
    textShadow += `${shadow.color};`;
  }
  return textShadow;
};
const getHoverStyle = (hover) => {
  return `
    &:hover {
      ${getCommonCss(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, (hover == null ? void 0 : hover.color) && { color: hover.color }), (hover == null ? void 0 : hover.backgroundColor) && {
    backgroundColor: hover.backgroundColor
  }), (hover == null ? void 0 : hover.background) && {
    background: hover.background
  }), (hover == null ? void 0 : hover.borderColor) && { borderColor: hover.borderColor }))}
      ${(hover == null ? void 0 : hover.transparent) ? `opacity: ${hover.transparent / 100};` : ""}
      ${(hover == null ? void 0 : hover.zoom) ? `transform: scale(${hover.zoom / 100})` : ""}
    }
    `;
};
const getAnimation = (animation) => {
  return `
    ${(animation == null ? void 0 : animation.name) ? `animation-name: ${animation.name};` : ""}
    ${isNumeric(animation == null ? void 0 : animation.delay) ? `animation-delay: ${animation.delay}s;` : ""}
    ${isNumeric(animation == null ? void 0 : animation.duration) ? `animation-duration: ${animation.duration}s;` : ""}
    ${(animation == null ? void 0 : animation.repeatType) === "infinite" ? `animation-iteration-count: infinite;` : isNumeric(animation == null ? void 0 : animation.repeatNumber) ? `animation-iteration-count: ${animation.repeatNumber};` : ""}
    `;
};
const getBackgroundImageUrl = (bgImage, bgImageWidth, bgImagePercent) => {
  const isUrlPrefix = /^url\((.*)\)$/.test(bgImage);
  if (!isUrlPrefix && bgImage) {
    return `url(${getImageUrlFromGoogleUserContent(bgImage, {
      width: bgImageWidth,
      percent: bgImagePercent
    })})`;
  }
  return bgImage;
};
const getBackgroundImagePlaceholderUrl = (bgImage) => {
  return getBackgroundImageUrl(bgImage, 200, 100);
};
const getDefaultOverlay = (value) => {
  if (value)
    return `
      & {
        position: relative;
        z-index: 0;

        &:before {
          position: absolute;
          top: 0;
          bottom: 0;
          left: 0;
          right: 0;
          content: '';
          background: #000;
          border-radius: inherit;
          z-index: -1;
          opacity: ${value};
        }
      }`;
  return "";
};
const getStyle = (props, opts = { lazyBgImage: false }) => {
  const { lazyBgImage } = opts;
  if (!props)
    return "";
  const _a = props, {
    margin = {},
    padding = {},
    border = {},
    shadow,
    textShadow,
    backgroundVideo,
    backgroundOverlay,
    backgroundOverlayType,
    bgImageWidth,
    bgImagePercent,
    backgroundImage,
    hover = {},
    animation = {},
    defaultOverlay,
    background,
    backgroundColor,
    backgroundPosition,
    backgroundRepeat,
    backgroundSize,
    backgroundMarqueeDirection,
    backgroundMarqueeSpeed,
    borderRadius,
    borderBottomLeftRadius,
    borderBottomRightRadius,
    borderTopLeftRadius,
    borderTopRightRadius,
    cornerType
  } = _a, rest = __objRest(_a, [
    "margin",
    "padding",
    "border",
    "shadow",
    "textShadow",
    "backgroundVideo",
    "backgroundOverlay",
    "backgroundOverlayType",
    "bgImageWidth",
    "bgImagePercent",
    "backgroundImage",
    "hover",
    "animation",
    "defaultOverlay",
    "background",
    "backgroundColor",
    "backgroundPosition",
    "backgroundRepeat",
    "backgroundSize",
    "backgroundMarqueeDirection",
    "backgroundMarqueeSpeed",
    "borderRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius",
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "cornerType"
  ]);
  const objBorderRadius = cornerType === "detail" ? {
    borderBottomLeftRadius,
    borderBottomRightRadius,
    borderTopLeftRadius,
    borderTopRightRadius
  } : { borderRadius };
  let bgCss = ``;
  if (!(backgroundVideo == null ? void 0 : backgroundVideo.src) && !(backgroundVideo == null ? void 0 : backgroundVideo.uploadSrc)) {
    bgCss += `${getCommonCss({
      background,
      backgroundColor
    })}`;
    if (backgroundImage) {
      const bgImage = getBackgroundImageUrl(
        backgroundImage,
        bgImageWidth,
        bgImagePercent
      );
      const bgImagePlaceHolder = getBackgroundImagePlaceholderUrl(backgroundImage);
      bgCss += bgImage !== bgImagePlaceHolder && lazyBgImage ? `
        background-image: ${bgImagePlaceHolder};
        &.${BG_VISIBLE_LAZY_CLASS_NAME} {
          background-image: ${bgImage};
        }
      ` : `
        background-image: ${bgImage};
      `;
      bgCss += getBackgroundImageMarquee(
        backgroundMarqueeDirection,
        backgroundMarqueeSpeed
      );
    }
    bgCss += `
      ${getBackgroundOverlay(backgroundOverlayType, backgroundOverlay)}
      ${getCommonCss({
      backgroundPosition,
      backgroundRepeat,
      backgroundSize
    })}
    `;
  } else {
    bgCss += `
      position: relative;
    `;
  }
  return `
    & {
      ${getBoxShadow(shadow)}
      ${getTextShadow(textShadow)}
      ${getCommonCss(__spreadValues(__spreadValues(__spreadValues({}, objBorderRadius), border), rest))}
      ${bgCss}
      ${getFourSideCss({ margin, padding })}
      ${getHoverStyle(hover)}
      ${getDefaultOverlay(defaultOverlay)}
    }
    `;
};
const getScrollbarWidth = () => {
  let width = 0;
  if (typeof window !== "undefined") {
    if (document.body.scrollHeight <= window.innerHeight)
      return 0;
    if (window.scrollbarWidth && document.body.scrollHeight > window.innerHeight) {
      return window.scrollbarWidth;
    }
    const outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.overflow = "scroll";
    document.body.appendChild(outer);
    const inner = document.createElement("div");
    outer.appendChild(inner);
    width = outer.offsetWidth - inner.offsetWidth;
    outer.parentNode.removeChild(outer);
  }
  return width;
};
const pixelParse = (value) => {
  if (typeof value === "number")
    return `${value}px`;
  return value;
};
const unitParse = (value, unit = UnitEnum.pixel) => {
  if (typeof value === "number")
    return `${value}${unit}`;
  return value;
};
const debounce = (fn, delay = 200) => {
  let timerId;
  return function(...args) {
    if (timerId) {
      clearTimeout(timerId);
    }
    timerId = setTimeout(() => {
      fn(...args);
      timerId = null;
    }, delay);
  };
};
const stringifyColor = (color) => {
  if (color.colorType === ColorType.solid)
    return color.colorValue;
  const gradientColor = color.colorValue;
  if (!gradientColor)
    return "";
  const cloneArr = [...gradientColor.colors];
  const gradientType = `${gradientColor.gradientType}-gradient`;
  const gradientRadius = gradientColor.gradientType === GradientType.radial ? "circle" : `${gradientColor.radius}deg`;
  const gradientList = cloneArr.sort((color1, color2) => color1.stop - color2.stop).map((color2) => `${color2.color} ${color2.stop}%`).join(",");
  return `${gradientType}(${gradientRadius}, ${gradientList})`;
};
const parseColor = (color) => {
  if (!color || typeof color !== "string")
    return;
  if (!color.includes("-gradient"))
    return {
      colorType: ColorType.solid,
      colorValue: color.includes("#") ? getRgbaFromHex(color) : color
    };
  const gradientType = color.slice(0, color.indexOf("-gradient"));
  const content = color.substring(
    color.indexOf("(") + 1,
    color.lastIndexOf(")")
  );
  const arr = content.split(
    /,(?![^(]*\))(?![^"']*["'](?:[^"']*["'][^"']*["'])*[^"']*$)/
  );
  const radius = arr.shift();
  const colorList = arr.map((colorString) => {
    const colorArray = colorString.trim().split(" ");
    return { color: colorArray[0], stop: parseInt(colorArray[1]) };
  });
  return {
    colorType: ColorType.gradient,
    colorValue: {
      colors: [...colorList],
      radius: parseInt(radius) || void 0,
      gradientType: gradientType === GradientType.linear ? GradientType.linear : GradientType.radial
    }
  };
};
const generateRandomId = (length = 7) => Math.random().toString(36).substring(1, length);
const escapeString = (text) => {
  if (!text)
    return "";
  const map = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#039;"
  };
  return text.replace(/[&<>"']/g, function(m) {
    return map[m];
  });
};
const unescapeString = (text) => {
  if (!text)
    return "";
  const map = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#039;": "'"
  };
  return text.replace(/&amp;|&lt;|&gt;|&quot;|&#039;/g, function(m) {
    return map[m];
  });
};
const formatCurrencyVND = (value, includeUnit = true) => {
  if (typeof value !== "number")
    return null;
  let currencyFormat;
  if (includeUnit)
    currencyFormat = new Intl.NumberFormat("vi-VN", {
      style: "currency",
      currency: "VND"
    });
  else
    currencyFormat = new Intl.NumberFormat("vi-VN");
  return currencyFormat.format(value);
};

export { debounce, escapeString, formatCurrencyVND, generateRandomId, getAnimation, getBackgroundImageMarquee, getBackgroundOverlay, getBoxShadow, getCommonCss, getScrollbarWidth, getStyle, parseColor, pixelParse, stringifyColor, unescapeString, unitParse };
