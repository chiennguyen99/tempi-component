'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var useIntersectionObserver = require('./useIntersectionObserver.js');

const useAnimation = (animation, animationRef) => {
  var _a;
  const isVisible = useIntersectionObserver.useIntersectionObserver(
    (animation == null ? void 0 : animation.name) ? animationRef : null,
    { freezeOnceVisible: true }
  );
  const [isFirstRender, setFirstRender] = React.useState(true);
  const [animationClassName, setClassName] = React.useState("animation-hidden");
  React.useEffect(() => {
    if (!(animation == null ? void 0 : animation.name) || !isFirstRender || !(animationRef == null ? void 0 : animationRef.current))
      return;
    if (isVisible && isFirstRender) {
      const timeout = setTimeout(() => {
        setClassName("");
        setFirstRender(false);
      }, ((animation == null ? void 0 : animation.delay) || 0) * 1e3 + 20);
      return () => clearTimeout(timeout);
    }
  }, [isVisible, animation, isFirstRender, animationRef]);
  if (!(animation == null ? void 0 : animation.name))
    return { style: {}, animationClassName: "" };
  if (isVisible && isFirstRender || !isFirstRender) {
    const style = {
      animationName: animation == null ? void 0 : animation.name,
      animationDelay: `${(animation == null ? void 0 : animation.delay) || 0}s`,
      animationDuration: `${(animation == null ? void 0 : animation.duration) || 0}s`,
      animationIterationCount: (animation == null ? void 0 : animation.repeatType) === "infinite" ? "infinite" : ((_a = animation == null ? void 0 : animation.repeatNumber) == null ? void 0 : _a.toString()) || "1"
    };
    return { style, animationClassName };
  }
  return { style: {}, animationClassName };
};

exports.useAnimation = useAnimation;
