import { useState, useEffect } from 'react';
import { useIntersectionObserver } from './useIntersectionObserver.es.js';

const useAnimation = (animation, animationRef) => {
  var _a;
  const isVisible = useIntersectionObserver(
    (animation == null ? void 0 : animation.name) ? animationRef : null,
    { freezeOnceVisible: true }
  );
  const [isFirstRender, setFirstRender] = useState(true);
  const [animationClassName, setClassName] = useState("animation-hidden");
  useEffect(() => {
    if (!(animation == null ? void 0 : animation.name) || !isFirstRender || !(animationRef == null ? void 0 : animationRef.current))
      return;
    if (isVisible && isFirstRender) {
      const timeout = setTimeout(() => {
        setClassName("");
        setFirstRender(false);
      }, ((animation == null ? void 0 : animation.delay) || 0) * 1e3 + 20);
      return () => clearTimeout(timeout);
    }
  }, [isVisible, animation, isFirstRender, animationRef]);
  if (!(animation == null ? void 0 : animation.name))
    return { style: {}, animationClassName: "" };
  if (isVisible && isFirstRender || !isFirstRender) {
    const style = {
      animationName: animation == null ? void 0 : animation.name,
      animationDelay: `${(animation == null ? void 0 : animation.delay) || 0}s`,
      animationDuration: `${(animation == null ? void 0 : animation.duration) || 0}s`,
      animationIterationCount: (animation == null ? void 0 : animation.repeatType) === "infinite" ? "infinite" : ((_a = animation == null ? void 0 : animation.repeatNumber) == null ? void 0 : _a.toString()) || "1"
    };
    return { style, animationClassName };
  }
  return { style: {}, animationClassName };
};

export { useAnimation };
