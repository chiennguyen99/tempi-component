import { getRandomId } from '@tempi/dnd-utils';
import React from 'react';
import { NodeProvider } from '../nodes/NodeContext.es.js';
import { Element, defaultElementProps, elementPropToNodeData } from '../nodes/Element.es.js';
import { Canvas, deprecateCanvasComponent } from '../nodes/Canvas.es.js';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const getNodeTypeName = (type) => typeof type == "string" ? type : type.name;
function createNode(newNode, normalize) {
  let actualType = newNode.data.type;
  const id = newNode.id || getRandomId();
  const node = {
    id,
    _hydrationTimestamp: Date.now(),
    data: __spreadValues({
      type: actualType,
      name: getNodeTypeName(actualType),
      displayName: getNodeTypeName(actualType),
      props: {},
      custom: {},
      parent: null,
      isCanvas: false,
      hidden: false,
      nodes: [],
      linkedNodes: {}
    }, newNode.data),
    related: {},
    events: {
      selected: false,
      dragged: false,
      hovered: false
    },
    rules: {
      canDrag: () => true,
      canDrop: () => true,
      canMoveIn: () => true,
      canMoveOut: () => true
    },
    dom: null
  };
  if (node.data.type === Element || node.data.type === Canvas) {
    const mergedProps = __spreadValues(__spreadValues({}, defaultElementProps), node.data.props);
    node.data.props = Object.keys(node.data.props).reduce((props, key) => {
      if (Object.keys(defaultElementProps).includes(key)) {
        node.data[elementPropToNodeData[key] || key] = mergedProps[key];
      } else {
        props[key] = node.data.props[key];
      }
      return props;
    }, {});
    actualType = node.data.type;
    node.data.name = getNodeTypeName(actualType);
    node.data.displayName = getNodeTypeName(actualType);
    const usingDeprecatedCanvas = node.data.type === Canvas;
    if (usingDeprecatedCanvas) {
      node.data.isCanvas = true;
      deprecateCanvasComponent();
    }
  }
  if (normalize) {
    normalize(node);
  }
  const userComponentConfig = actualType.craft;
  if (userComponentConfig) {
    node.data.displayName = userComponentConfig.displayName || userComponentConfig.name || node.data.displayName;
    node.data.props = __spreadValues(__spreadValues({}, userComponentConfig.props || userComponentConfig.defaultProps || {}), node.data.props);
    node.data.custom = __spreadValues(__spreadValues({}, userComponentConfig.custom || {}), node.data.custom);
    if (userComponentConfig.isCanvas !== void 0 && userComponentConfig.isCanvas !== null) {
      node.data.isCanvas = userComponentConfig.isCanvas;
    }
    if (userComponentConfig.rules) {
      Object.keys(userComponentConfig.rules).forEach((key) => {
        if (["canDrag", "canDrop", "canMoveIn", "canMoveOut"].includes(key)) {
          node.rules[key] = userComponentConfig.rules[key];
        }
      });
    }
    if (userComponentConfig.related) {
      const relatedNodeContext = {
        id: node.id,
        related: true
      };
      Object.keys(userComponentConfig.related).forEach((comp) => {
        node.related[comp] = () => React.createElement(
          NodeProvider,
          relatedNodeContext,
          React.createElement(userComponentConfig.related[comp])
        );
      });
    }
  }
  return node;
}

export { createNode };
