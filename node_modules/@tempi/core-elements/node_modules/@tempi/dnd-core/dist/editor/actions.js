'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dndUtils = require('@tempi/dnd-utils');
var invariant = require('tiny-invariant');
var fromEntries = require('../utils/fromEntries.js');
var getNodesFromSelector = require('../utils/getNodesFromSelector.js');
var removeNodeFromEvents = require('../utils/removeNodeFromEvents.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Methods = (state, query) => {
  const addNodeTreeToParent = (tree, parentId, addNodeType) => {
    const iterateChildren = (id, parentId2) => {
      const node = tree.nodes[id];
      if (typeof node.data.type !== "string") {
        invariant__default["default"](
          state.options.resolver[node.data.name],
          dndUtils.ERROR_NOT_IN_RESOLVER.replace(
            "%node_type%",
            `${node.data.type.name}`
          )
        );
      }
      state.nodes[id] = __spreadProps(__spreadValues({}, node), {
        data: __spreadProps(__spreadValues({}, node.data), {
          parent: parentId2
        })
      });
      if (node.data.nodes.length > 0) {
        delete state.nodes[id].data.props.children;
        node.data.nodes.forEach(
          (childNodeId) => iterateChildren(childNodeId, node.id)
        );
      }
      Object.values(node.data.linkedNodes).forEach(
        (linkedNodeId) => iterateChildren(linkedNodeId, node.id)
      );
    };
    iterateChildren(tree.rootNodeId, parentId);
    if (!parentId) {
      invariant__default["default"](
        tree.rootNodeId === dndUtils.ROOT_NODE,
        "Cannot add non-root Node without a parent"
      );
      return;
    }
    const parent = getParentAndValidate(parentId);
    if (addNodeType.type === "child") {
      const index = addNodeType.index;
      if (index != null) {
        parent.data.nodes.splice(index, 0, tree.rootNodeId);
      } else {
        parent.data.nodes.push(tree.rootNodeId);
      }
      return;
    }
    parent.data.linkedNodes[addNodeType.id] = tree.rootNodeId;
  };
  const getParentAndValidate = (parentId) => {
    invariant__default["default"](parentId, dndUtils.ERROR_NOPARENT);
    const parent = state.nodes[parentId];
    invariant__default["default"](parent, dndUtils.ERROR_INVALID_NODEID);
    return parent;
  };
  const deleteNode = (id) => {
    const targetNode = state.nodes[id], parentNode = state.nodes[targetNode.data.parent];
    if (targetNode.data.nodes) {
      [...targetNode.data.nodes].forEach((childId) => deleteNode(childId));
    }
    if (targetNode.data.linkedNodes) {
      Object.values(targetNode.data.linkedNodes).map(
        (linkedNodeId) => deleteNode(linkedNodeId)
      );
    }
    const isChildNode = parentNode.data.nodes.includes(id);
    if (isChildNode) {
      const parentChildren = parentNode.data.nodes;
      parentChildren.splice(parentChildren.indexOf(id), 1);
    } else {
      const linkedId = Object.keys(parentNode.data.linkedNodes).find(
        (id2) => parentNode.data.linkedNodes[id2] === id2
      );
      if (linkedId) {
        delete parentNode.data.linkedNodes[linkedId];
      }
    }
    removeNodeFromEvents.removeNodeFromEvents(state, id);
    delete state.nodes[id];
  };
  return {
    addLinkedNodeFromTree(tree, parentId, id) {
      const parent = getParentAndValidate(parentId);
      const existingLinkedNode = parent.data.linkedNodes[id];
      if (existingLinkedNode) {
        deleteNode(existingLinkedNode);
      }
      addNodeTreeToParent(tree, parentId, { type: "linked", id });
    },
    add(nodeToAdd, parentId, index) {
      let nodes = [nodeToAdd];
      if (Array.isArray(nodeToAdd)) {
        dndUtils.deprecationWarning("actions.add(node: Node[])", {
          suggest: "actions.add(node: Node)"
        });
        nodes = nodeToAdd;
      }
      nodes.forEach((node) => {
        addNodeTreeToParent(
          {
            nodes: {
              [node.id]: node
            },
            rootNodeId: node.id
          },
          parentId,
          { type: "child", index }
        );
      });
    },
    addNodeTree(tree, parentId, index) {
      addNodeTreeToParent(tree, parentId, { type: "child", index });
    },
    delete(selector) {
      const targets = getNodesFromSelector.getNodesFromSelector(state.nodes, selector, {
        existOnly: true,
        idOnly: true
      });
      targets.forEach(({ node }) => {
        invariant__default["default"](
          !query.node(node.id).isTopLevelNode(),
          dndUtils.ERROR_DELETE_TOP_LEVEL_NODE
        );
        deleteNode(node.id);
      });
    },
    deserialize(input) {
      const unDeserializedNodeIds = {};
      try {
        const dehydratedNodes = typeof input == "string" ? JSON.parse(input) : input;
        const nodePairs = Object.keys(dehydratedNodes).map((id) => {
          var _a;
          try {
            let nodeId = id;
            if (id === dndUtils.DEPRECATED_ROOT_NODE) {
              nodeId = dndUtils.ROOT_NODE;
            }
            return [
              nodeId,
              query.parseSerializedNode(dehydratedNodes[id]).toNode((node) => node.id = nodeId)
            ];
          } catch (e) {
            const nodeData = dehydratedNodes[id];
            console.log(
              `Cannot found resolver ${nodeData.displayName || ((_a = nodeData == null ? void 0 : nodeData.type) == null ? void 0 : _a.resolvedName)}`
            );
            unDeserializedNodeIds[id] = true;
          }
        }).filter(Boolean);
        if (!Object.keys(unDeserializedNodeIds).length)
          nodePairs.forEach(([_, nodeInfo]) => {
            var _a, _b;
            if (typeof nodeInfo !== "string" && ((_b = (_a = nodeInfo == null ? void 0 : nodeInfo.data) == null ? void 0 : _a.nodes) == null ? void 0 : _b.length)) {
              const filterChildren = nodeInfo.data.nodes.filter(
                (nodeId) => !unDeserializedNodeIds[nodeId]
              );
              nodeInfo.data.nodes = filterChildren;
            }
          });
        this.replaceNodes(fromEntries.fromEntries(nodePairs));
      } catch (e) {
        console.error(e);
      }
    },
    move(selector, newParentId, index) {
      const targets = getNodesFromSelector.getNodesFromSelector(state.nodes, selector, {
        existOnly: true
      });
      const newParent = state.nodes[newParentId];
      const nodesArrToCleanup = /* @__PURE__ */ new Set();
      targets.forEach(({ node: targetNode }, i) => {
        const targetId = targetNode.id;
        const currentParentId = targetNode.data.parent;
        query.node(newParentId).isDroppable([targetId], (err) => {
          throw new Error(err);
        });
        state.options.onBeforeMoveEnd(
          targetNode,
          newParent,
          state.nodes[currentParentId]
        );
        const currentParent = state.nodes[currentParentId];
        const currentParentNodes = currentParent.data.nodes;
        nodesArrToCleanup.add(currentParentNodes);
        const oldIndex = currentParentNodes.indexOf(targetId);
        currentParentNodes[oldIndex] = "$$";
        newParent.data.nodes.splice(index + i, 0, targetId);
        state.nodes[targetId].data.parent = newParentId;
      });
      nodesArrToCleanup.forEach((nodes) => {
        const length = nodes.length;
        [...nodes].reverse().forEach((value, index2) => {
          if (value !== "$$") {
            return;
          }
          nodes.splice(length - 1 - index2, 1);
        });
      });
    },
    replaceNodes(nodes) {
      this.clearEvents();
      state.nodes = nodes;
    },
    clearEvents() {
      this.setNodeEvent("selected", null);
      this.setNodeEvent("hovered", null);
      this.setNodeEvent("dragged", null);
      this.setIndicator(null);
    },
    reset() {
      this.clearEvents();
      this.replaceNodes({});
    },
    setOptions(cb) {
      cb(state.options);
    },
    setNodeEvent(eventType, nodeIdSelector) {
      state.events[eventType].forEach((id) => {
        if (state.nodes[id]) {
          state.nodes[id].events[eventType] = false;
        }
      });
      state.events[eventType] = /* @__PURE__ */ new Set();
      if (!nodeIdSelector) {
        return;
      }
      const targets = getNodesFromSelector.getNodesFromSelector(state.nodes, nodeIdSelector, {
        idOnly: true,
        existOnly: true
      });
      const nodeIds = new Set(targets.map(({ node }) => node.id));
      nodeIds.forEach((id) => {
        state.nodes[id].events[eventType] = true;
      });
      state.events[eventType] = nodeIds;
    },
    setCustom(selector, cb) {
      const targets = getNodesFromSelector.getNodesFromSelector(state.nodes, selector, {
        idOnly: true,
        existOnly: true
      });
      targets.forEach(({ node }) => cb(state.nodes[node.id].data.custom));
    },
    setDOM(id, dom) {
      if (!state.nodes[id]) {
        return;
      }
      state.nodes[id].dom = dom;
    },
    setIndicator(indicator) {
      if (indicator && (!indicator.placement.parent.dom || indicator.placement.currentNode && !indicator.placement.currentNode.dom))
        return;
      state.indicator = indicator;
    },
    setHidden(id, bool) {
      state.nodes[id].data.hidden = bool;
    },
    setProp(selector, cb) {
      const targets = getNodesFromSelector.getNodesFromSelector(state.nodes, selector, {
        idOnly: true,
        existOnly: true
      });
      targets.forEach(({ node }) => cb(state.nodes[node.id].data.props));
    },
    selectNode(nodeIdSelector) {
      if (nodeIdSelector) {
        const targets = getNodesFromSelector.getNodesFromSelector(state.nodes, nodeIdSelector, {
          idOnly: true,
          existOnly: true
        });
        this.setNodeEvent(
          "selected",
          targets.map(({ node }) => node.id)
        );
      } else {
        this.setNodeEvent("selected", null);
      }
      this.setNodeEvent("hovered", null);
    }
  };
};
const ActionMethods = (state, query) => {
  return __spreadProps(__spreadValues({}, Methods(state, query)), {
    setState(cb) {
      const _a = this, actions = __objRest(_a, ["history"]);
      cb(state, actions);
    }
  });
};

exports.ActionMethods = ActionMethods;
