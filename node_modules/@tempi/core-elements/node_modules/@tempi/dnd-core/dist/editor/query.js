'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dndUtils = require('@tempi/dnd-utils');
var React = require('react');
var invariant = require('tiny-invariant');
var EventHelpers = require('./EventHelpers.js');
var NodeHelpers = require('./NodeHelpers.js');
var findPosition = require('../events/findPosition.js');
var createNode = require('../utils/createNode.js');
var deserializeNode = require('../utils/deserializeNode.js');
var fromEntries = require('../utils/fromEntries.js');
var getNodesFromSelector = require('../utils/getNodesFromSelector.js');
var mergeTrees = require('../utils/mergeTrees.js');
var parseNodeFromJSX = require('../utils/parseNodeFromJSX.js');
var resolveComponent = require('../utils/resolveComponent.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function QueryMethods(state) {
  const options = state && state.options;
  const _ = () => QueryMethods(state);
  return {
    getDropPlaceholder: (source, target, pos, nodesToDOM = (node) => state.nodes[node.id].dom) => {
      const targetNode = state.nodes[target], isTargetCanvas = _().node(targetNode.id).isCanvas();
      const targetParent = isTargetCanvas ? targetNode : state.nodes[targetNode.data.parent];
      if (!targetParent)
        return;
      const targetParentNodes = targetParent.data.nodes || [];
      const dimensionsInContainer = targetParentNodes ? targetParentNodes.reduce((result, id) => {
        const dom = nodesToDOM(state.nodes[id]);
        if (dom) {
          const info = __spreadValues({
            id
          }, dndUtils.getDOMInfo(dom));
          result.push(info);
        }
        return result;
      }, []) : [];
      const dropAction = findPosition(
        targetParent,
        dimensionsInContainer,
        pos.x,
        pos.y
      );
      const currentNode = targetParentNodes.length && state.nodes[targetParentNodes[dropAction.index]];
      const output = {
        placement: __spreadProps(__spreadValues({}, dropAction), {
          currentNode
        }),
        error: null
      };
      const sourceNodes = getNodesFromSelector.getNodesFromSelector(state.nodes, source);
      sourceNodes.forEach(({ node, exists }) => {
        if (exists) {
          _().node(node.id).isDraggable((err) => output.error = err);
        }
      });
      _().node(targetParent.id).isDroppable(source, (err) => output.error = err);
      return output;
    },
    getOptions() {
      return options;
    },
    getNodes() {
      return state.nodes;
    },
    node(id) {
      return NodeHelpers.NodeHelpers(state, id);
    },
    getSerializedNodes() {
      const nodePairs = Object.keys(state.nodes).map((id) => [
        id,
        this.node(id).toSerializedNode()
      ]);
      return fromEntries.fromEntries(nodePairs);
    },
    getEvent(eventType) {
      return EventHelpers.EventHelpers(state, eventType);
    },
    serialize() {
      return JSON.stringify(this.getSerializedNodes());
    },
    parseReactElement: (reactElement) => ({
      toNodeTree(normalize) {
        const node = parseNodeFromJSX.parseNodeFromJSX(reactElement, (node2, jsx) => {
          const name = resolveComponent.resolveComponent(state.options.resolver, node2.data.type);
          node2.data.displayName = node2.data.displayName || name;
          node2.data.name = name;
          if (normalize) {
            normalize(node2, jsx);
          }
        });
        let childrenNodes = [];
        if (reactElement.props && reactElement.props.children) {
          childrenNodes = React__default["default"].Children.toArray(
            reactElement.props.children
          ).reduce((accum, child) => {
            if (React__default["default"].isValidElement(child)) {
              accum.push(_().parseReactElement(child).toNodeTree(normalize));
            }
            return accum;
          }, []);
        }
        return mergeTrees.mergeTrees(node, childrenNodes);
      }
    }),
    parseSerializedNode: (serializedNode) => ({
      toNode(normalize) {
        const data = deserializeNode.deserializeNode(serializedNode, state.options.resolver);
        invariant__default["default"](data.type, dndUtils.ERROR_NOT_IN_RESOLVER);
        const id = typeof normalize === "string" && normalize;
        if (id) {
          dndUtils.deprecationWarning(`query.parseSerializedNode(...).toNode(id)`, {
            suggest: `query.parseSerializedNode(...).toNode(node => node.id = id)`
          });
        }
        return _().parseFreshNode(__spreadProps(__spreadValues({}, id ? { id } : {}), {
          data
        })).toNode(!id && normalize);
      }
    }),
    parseFreshNode: (node) => ({
      toNode(normalize) {
        return createNode.createNode(node, (node2) => {
          if (node2.data.parent === dndUtils.DEPRECATED_ROOT_NODE) {
            node2.data.parent = dndUtils.ROOT_NODE;
          }
          const name = resolveComponent.resolveComponent(state.options.resolver, node2.data.type);
          invariant__default["default"](name !== null, dndUtils.ERROR_NOT_IN_RESOLVER);
          node2.data.displayName = node2.data.displayName || name;
          node2.data.name = name;
          if (normalize) {
            normalize(node2);
          }
        });
      }
    }),
    createNode(reactElement, extras) {
      dndUtils.deprecationWarning(`query.createNode(${reactElement})`, {
        suggest: `query.parseReactElement(${reactElement}).toNodeTree()`
      });
      const tree = this.parseReactElement(reactElement).toNodeTree();
      const node = tree.nodes[tree.rootNodeId];
      if (!extras) {
        return node;
      }
      if (extras.id) {
        node.id = extras.id;
      }
      if (extras.data) {
        node.data = __spreadValues(__spreadValues({}, node.data), extras.data);
      }
      return node;
    },
    getState() {
      return state;
    }
  };
}

exports.QueryMethods = QueryMethods;
