import { getDOMInfo, ERROR_NOT_IN_RESOLVER, deprecationWarning, DEPRECATED_ROOT_NODE, ROOT_NODE } from '@tempi/dnd-utils';
import React from 'react';
import invariant from 'tiny-invariant';
import { EventHelpers } from './EventHelpers.es.js';
import { NodeHelpers } from './NodeHelpers.es.js';
import findPosition from '../events/findPosition.es.js';
import { createNode } from '../utils/createNode.es.js';
import { deserializeNode } from '../utils/deserializeNode.es.js';
import { fromEntries } from '../utils/fromEntries.es.js';
import { getNodesFromSelector } from '../utils/getNodesFromSelector.es.js';
import { mergeTrees } from '../utils/mergeTrees.es.js';
import { parseNodeFromJSX } from '../utils/parseNodeFromJSX.es.js';
import { resolveComponent } from '../utils/resolveComponent.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function QueryMethods(state) {
  const options = state && state.options;
  const _ = () => QueryMethods(state);
  return {
    getDropPlaceholder: (source, target, pos, nodesToDOM = (node) => state.nodes[node.id].dom) => {
      const targetNode = state.nodes[target], isTargetCanvas = _().node(targetNode.id).isCanvas();
      const targetParent = isTargetCanvas ? targetNode : state.nodes[targetNode.data.parent];
      if (!targetParent)
        return;
      const targetParentNodes = targetParent.data.nodes || [];
      const dimensionsInContainer = targetParentNodes ? targetParentNodes.reduce((result, id) => {
        const dom = nodesToDOM(state.nodes[id]);
        if (dom) {
          const info = __spreadValues({
            id
          }, getDOMInfo(dom));
          result.push(info);
        }
        return result;
      }, []) : [];
      const dropAction = findPosition(
        targetParent,
        dimensionsInContainer,
        pos.x,
        pos.y
      );
      const currentNode = targetParentNodes.length && state.nodes[targetParentNodes[dropAction.index]];
      const output = {
        placement: __spreadProps(__spreadValues({}, dropAction), {
          currentNode
        }),
        error: null
      };
      const sourceNodes = getNodesFromSelector(state.nodes, source);
      sourceNodes.forEach(({ node, exists }) => {
        if (exists) {
          _().node(node.id).isDraggable((err) => output.error = err);
        }
      });
      _().node(targetParent.id).isDroppable(source, (err) => output.error = err);
      return output;
    },
    getOptions() {
      return options;
    },
    getNodes() {
      return state.nodes;
    },
    node(id) {
      return NodeHelpers(state, id);
    },
    getSerializedNodes() {
      const nodePairs = Object.keys(state.nodes).map((id) => [
        id,
        this.node(id).toSerializedNode()
      ]);
      return fromEntries(nodePairs);
    },
    getEvent(eventType) {
      return EventHelpers(state, eventType);
    },
    serialize() {
      return JSON.stringify(this.getSerializedNodes());
    },
    parseReactElement: (reactElement) => ({
      toNodeTree(normalize) {
        const node = parseNodeFromJSX(reactElement, (node2, jsx) => {
          const name = resolveComponent(state.options.resolver, node2.data.type);
          node2.data.displayName = node2.data.displayName || name;
          node2.data.name = name;
          if (normalize) {
            normalize(node2, jsx);
          }
        });
        let childrenNodes = [];
        if (reactElement.props && reactElement.props.children) {
          childrenNodes = React.Children.toArray(
            reactElement.props.children
          ).reduce((accum, child) => {
            if (React.isValidElement(child)) {
              accum.push(_().parseReactElement(child).toNodeTree(normalize));
            }
            return accum;
          }, []);
        }
        return mergeTrees(node, childrenNodes);
      }
    }),
    parseSerializedNode: (serializedNode) => ({
      toNode(normalize) {
        const data = deserializeNode(serializedNode, state.options.resolver);
        invariant(data.type, ERROR_NOT_IN_RESOLVER);
        const id = typeof normalize === "string" && normalize;
        if (id) {
          deprecationWarning(`query.parseSerializedNode(...).toNode(id)`, {
            suggest: `query.parseSerializedNode(...).toNode(node => node.id = id)`
          });
        }
        return _().parseFreshNode(__spreadProps(__spreadValues({}, id ? { id } : {}), {
          data
        })).toNode(!id && normalize);
      }
    }),
    parseFreshNode: (node) => ({
      toNode(normalize) {
        return createNode(node, (node2) => {
          if (node2.data.parent === DEPRECATED_ROOT_NODE) {
            node2.data.parent = ROOT_NODE;
          }
          const name = resolveComponent(state.options.resolver, node2.data.type);
          invariant(name !== null, ERROR_NOT_IN_RESOLVER);
          node2.data.displayName = node2.data.displayName || name;
          node2.data.name = name;
          if (normalize) {
            normalize(node2);
          }
        });
      }
    }),
    createNode(reactElement, extras) {
      deprecationWarning(`query.createNode(${reactElement})`, {
        suggest: `query.parseReactElement(${reactElement}).toNodeTree()`
      });
      const tree = this.parseReactElement(reactElement).toNodeTree();
      const node = tree.nodes[tree.rootNodeId];
      if (!extras) {
        return node;
      }
      if (extras.id) {
        node.id = extras.id;
      }
      if (extras.data) {
        node.data = __spreadValues(__spreadValues({}, node.data), extras.data);
      }
      return node;
    },
    getState() {
      return state;
    }
  };
}

export { QueryMethods };
