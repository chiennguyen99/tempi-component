'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var dndUtils = require('@tempi/dnd-utils');
var pickBy = require('lodash.pickby');
var React = require('react');
var invariant = require('tiny-invariant');
var EditorContext = require('./EditorContext.js');
var store = require('./store.js');
var Events = require('../events/Events.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var pickBy__default = /*#__PURE__*/_interopDefaultLegacy(pickBy);
var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Editor = ({
  children,
  onRender,
  onNodesChange,
  onBeforeMoveEnd,
  resolver,
  enabled,
  indicator
}) => {
  if (resolver !== void 0) {
    invariant__default["default"](
      typeof resolver === "object" && !Array.isArray(resolver),
      dndUtils.ERROR_RESOLVER_NOT_AN_OBJECT
    );
  }
  const options = React.useMemo(() => {
    return pickBy__default["default"](
      {
        onRender,
        onNodesChange,
        onBeforeMoveEnd,
        resolver,
        enabled,
        indicator
      },
      (value) => value !== void 0
    );
  }, [enabled, indicator, onBeforeMoveEnd, onNodesChange, onRender, resolver]);
  const context = store.useEditorStore(
    options,
    (state, previousState, actionPerformedWithPatches, query, normalizer) => {
      if (!actionPerformedWithPatches) {
        return;
      }
      const _a = actionPerformedWithPatches, { patches } = _a, actionPerformed = __objRest(_a, ["patches"]);
      for (let i = 0; i < patches.length; i++) {
        const { path } = patches[i];
        const isModifyingNodeData = path.length > 2 && path[0] === "nodes" && path[2] === "data";
        const actionType = actionPerformed.type;
        if ([dndUtils.HISTORY_ACTIONS.IGNORE, dndUtils.HISTORY_ACTIONS.THROTTLE].includes(
          actionType
        ) && actionPerformed.params) {
          actionPerformed.type = actionPerformed.params[0];
        }
        if (["setState", "deserialize"].includes(actionPerformed.type) || isModifyingNodeData) {
          normalizer((draft) => {
            if (state.options.normalizeNodes) {
              state.options.normalizeNodes(
                draft,
                previousState,
                actionPerformed,
                query
              );
            }
          });
          break;
        }
      }
    }
  );
  React.useEffect(() => {
    if (context && options) {
      context.actions.setOptions((editorOptions) => {
        Object.assign(editorOptions, options);
      });
    }
  }, [context, options]);
  React.useEffect(() => {
    context.subscribe(
      (_) => ({
        json: context.query.serialize()
      }),
      () => {
        context.query.getOptions().onNodesChange(context.query);
      }
    );
  }, [context]);
  return context ? /* @__PURE__ */ jsxRuntime.jsx(EditorContext.EditorContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntime.jsx(Events.Events, {
      children
    })
  }) : null;
};

exports.Editor = Editor;
