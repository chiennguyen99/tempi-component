'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dndUtils = require('@tempi/dnd-utils');
var isFunction = require('lodash.isfunction');
var React = require('react');
var CoreEventHandlers = require('./CoreEventHandlers.js');
var Positioner = require('./Positioner.js');
var createShadow = require('./createShadow.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isFunction__default = /*#__PURE__*/_interopDefaultLegacy(isFunction);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

const _DefaultEventHandlers = class extends CoreEventHandlers.CoreEventHandlers {
  constructor() {
    super(...arguments);
    this.positioner = null;
    this.currentSelectedElementIds = [];
  }
  onDisable() {
    this.options.store.actions.clearEvents();
  }
  handlers() {
    const store = this.options.store;
    return {
      connect: (el, id) => {
        store.actions.setDOM(id, el);
        return this.reflect((connectors) => {
          connectors.select(el, id);
          connectors.hover(el, id);
          connectors.drop(el, id);
        });
      },
      select: (el, id) => {
        const unbindOnMouseDown = this.addCraftEventListener(
          el,
          "mousedown",
          (e) => {
            e.craft.stopPropagation();
            let newSelectedElementIds = [];
            if (id) {
              const { query } = store;
              const selectedElementIds = query.getEvent("selected").all();
              const isMultiSelect = this.options.isMultiSelectEnabled(e);
              if (isMultiSelect || selectedElementIds.includes(id)) {
                newSelectedElementIds = selectedElementIds.filter(
                  (selectedId) => {
                    const descendants = query.node(selectedId).descendants(true);
                    const ancestors = query.node(selectedId).ancestors(true);
                    if (descendants.includes(id) || ancestors.includes(id)) {
                      return false;
                    }
                    return true;
                  }
                );
              }
              if (!newSelectedElementIds.includes(id)) {
                newSelectedElementIds.push(id);
              }
            }
            store.actions.setNodeEvent("selected", newSelectedElementIds);
          }
        );
        const unbindOnClick = this.addCraftEventListener(el, "click", (e) => {
          e.craft.stopPropagation();
          const { query } = store;
          const selectedElementIds = query.getEvent("selected").all();
          const isMultiSelect = this.options.isMultiSelectEnabled(e);
          const isNodeAlreadySelected = this.currentSelectedElementIds.includes(id);
          let newSelectedElementIds = [...selectedElementIds];
          if (isMultiSelect && isNodeAlreadySelected) {
            newSelectedElementIds.splice(newSelectedElementIds.indexOf(id), 1);
            store.actions.setNodeEvent("selected", newSelectedElementIds);
          } else if (!isMultiSelect && selectedElementIds.length > 1) {
            newSelectedElementIds = [id];
            store.actions.setNodeEvent("selected", newSelectedElementIds);
          }
          this.currentSelectedElementIds = newSelectedElementIds;
        });
        return () => {
          unbindOnMouseDown();
          unbindOnClick();
        };
      },
      hover: (el, id) => {
        const unbindMouseover = this.addCraftEventListener(
          el,
          "mouseover",
          (e) => {
            e.craft.stopPropagation();
            store.actions.setNodeEvent("hovered", id);
          }
        );
        return () => {
          unbindMouseover();
        };
      },
      drop: (el, targetId) => {
        const unbindDragOver = this.addCraftEventListener(
          el,
          "dragover",
          (e) => {
            e.craft.stopPropagation();
            e.preventDefault();
            if (!this.positioner) {
              return;
            }
            const indicator = this.positioner.computeIndicator(
              targetId,
              e.clientX,
              e.clientY
            );
            if (!indicator) {
              return;
            }
            store.actions.setIndicator(indicator);
          }
        );
        const unbindDragEnter = this.addCraftEventListener(
          el,
          "dragenter",
          (e) => {
            e.craft.stopPropagation();
            e.preventDefault();
          }
        );
        return () => {
          unbindDragEnter();
          unbindDragOver();
        };
      },
      drag: (el, id) => {
        if (!store.query.node(id).isDraggable()) {
          return () => {
          };
        }
        el.setAttribute("draggable", "true");
        const unbindDragStart = this.addCraftEventListener(
          el,
          "dragstart",
          (e) => {
            e.craft.stopPropagation();
            const { query, actions } = store;
            let selectedElementIds = query.getEvent("selected").all();
            const isMultiSelect = this.options.isMultiSelectEnabled(e);
            const isNodeAlreadySelected = this.currentSelectedElementIds.includes(id);
            if (!isNodeAlreadySelected) {
              if (isMultiSelect) {
                selectedElementIds = [...selectedElementIds, id];
              } else {
                selectedElementIds = [id];
              }
              store.actions.setNodeEvent("selected", selectedElementIds);
            }
            actions.setNodeEvent("dragged", selectedElementIds);
            const selectedDOMs = selectedElementIds.map(
              (id2) => query.node(id2).get().dom
            );
            this.draggedElementShadow = createShadow.createShadow(
              e,
              selectedDOMs,
              _DefaultEventHandlers.forceSingleDragShadow
            );
            this.dragTarget = {
              type: "existing",
              nodes: selectedElementIds
            };
            this.positioner = new Positioner.Positioner(
              this.options.store,
              this.dragTarget
            );
          }
        );
        const unbindDragEnd = this.addCraftEventListener(el, "dragend", (e) => {
          e.craft.stopPropagation();
          this.dropElement((dragTarget, indicator) => {
            if (dragTarget.type === "new") {
              return;
            }
            const index = indicator.placement.index + (indicator.placement.where === "after" ? 1 : 0);
            store.actions.move(
              dragTarget.nodes,
              indicator.placement.parent.id,
              index
            );
          });
        });
        return () => {
          el.setAttribute("draggable", "false");
          unbindDragStart();
          unbindDragEnd();
        };
      },
      create: (el, userElement, options) => {
        el.setAttribute("draggable", "true");
        const unbindDragStart = this.addCraftEventListener(
          el,
          "dragstart",
          (e) => {
            e.craft.stopPropagation();
            let tree;
            if (typeof userElement === "function") {
              const result = userElement();
              if (React__default["default"].isValidElement(result)) {
                tree = store.query.parseReactElement(result).toNodeTree();
              } else {
                tree = result;
              }
            } else {
              tree = store.query.parseReactElement(userElement).toNodeTree();
            }
            const dom = e.currentTarget;
            this.draggedElementShadow = createShadow.createShadow(
              e,
              [dom],
              _DefaultEventHandlers.forceSingleDragShadow
            );
            this.dragTarget = {
              type: "new",
              tree
            };
            this.positioner = new Positioner.Positioner(
              this.options.store,
              this.dragTarget
            );
          }
        );
        const unbindDragEnd = this.addCraftEventListener(el, "dragend", (e) => {
          e.craft.stopPropagation();
          this.dropElement((dragTarget, indicator) => {
            if (dragTarget.type === "existing") {
              return;
            }
            const index = indicator.placement.index + (indicator.placement.where === "after" ? 1 : 0);
            store.actions.addNodeTree(
              dragTarget.tree,
              indicator.placement.parent.id,
              index
            );
            if (options && isFunction__default["default"](options.onCreate)) {
              options.onCreate(dragTarget.tree);
            }
          });
        });
        return () => {
          el.removeAttribute("draggable");
          unbindDragStart();
          unbindDragEnd();
        };
      }
    };
  }
  dropElement(onDropNode) {
    const store = this.options.store;
    if (!this.positioner) {
      return;
    }
    const draggedElementShadow = this.draggedElementShadow;
    const indicator = this.positioner.getIndicator();
    if (this.dragTarget && indicator && !indicator.error) {
      onDropNode(this.dragTarget, indicator);
    }
    if (draggedElementShadow) {
      draggedElementShadow.parentNode.removeChild(draggedElementShadow);
      this.draggedElementShadow = null;
    }
    this.dragTarget = null;
    store.actions.setIndicator(null);
    store.actions.setNodeEvent("dragged", null);
    this.positioner.cleanup();
    this.positioner = null;
  }
};
let DefaultEventHandlers = _DefaultEventHandlers;
DefaultEventHandlers.forceSingleDragShadow = dndUtils.isChromium() && dndUtils.isLinux();

exports.DefaultEventHandlers = DefaultEventHandlers;
