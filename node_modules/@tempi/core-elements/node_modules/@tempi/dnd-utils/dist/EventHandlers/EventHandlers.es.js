import { ConnectorRegistry } from './ConnectorRegistry.es.js';
import { EventHandlerUpdates } from './interfaces.es.js';
import { isEventBlockedByDescendant } from './isEventBlockedByDescendant.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
class EventHandlers {
  constructor(options) {
    this.registry = new ConnectorRegistry();
    this.subscribers = /* @__PURE__ */ new Set();
    this.options = options;
  }
  listen(cb) {
    this.subscribers.add(cb);
    return () => this.subscribers.delete(cb);
  }
  disable() {
    if (this.onDisable) {
      this.onDisable();
    }
    this.registry.disable();
    this.subscribers.forEach((listener) => {
      listener(EventHandlerUpdates.HandlerDisabled);
    });
  }
  enable() {
    if (this.onEnable) {
      this.onEnable();
    }
    this.registry.enable();
    this.subscribers.forEach((listener) => {
      listener(EventHandlerUpdates.HandlerEnabled);
    });
  }
  cleanup() {
    this.disable();
    this.subscribers.clear();
    this.registry.clear();
  }
  addCraftEventListener(el, eventName, listener, options) {
    const bindedListener = (e) => {
      if (!isEventBlockedByDescendant(e, eventName, el)) {
        e.craft.stopPropagation = () => {
          if (!e.craft.blockedEvents[eventName]) {
            e.craft.blockedEvents[eventName] = [];
          }
          e.craft.blockedEvents[eventName].push(el);
        };
        listener(e);
      }
    };
    el.addEventListener(eventName, bindedListener, options);
    return () => el.removeEventListener(eventName, bindedListener, options);
  }
  createConnectorsUsage() {
    const handlers = this.handlers();
    const activeConnectorIds = /* @__PURE__ */ new Set();
    let canRegisterConnectors = false;
    const connectorsToRegister = /* @__PURE__ */ new Map();
    const connectors = Object.entries(handlers).reduce(
      (accum, [name, handler]) => __spreadProps(__spreadValues({}, accum), {
        [name]: (el, required, options) => {
          const registerConnector = () => {
            const connector = this.registry.register(el, {
              required,
              name,
              options,
              connector: handler
            });
            activeConnectorIds.add(connector.id);
            return connector;
          };
          connectorsToRegister.set(
            this.registry.getConnectorId(el, name),
            registerConnector
          );
          if (canRegisterConnectors) {
            registerConnector();
          }
          return el;
        }
      }),
      {}
    );
    return {
      connectors,
      register: () => {
        canRegisterConnectors = true;
        connectorsToRegister.forEach((registerConnector) => {
          registerConnector();
        });
      },
      cleanup: () => {
        canRegisterConnectors = false;
        activeConnectorIds.forEach(
          (connectorId) => this.registry.remove(connectorId)
        );
      }
    };
  }
  derive(type, opts) {
    return new type(this, opts);
  }
  createProxyHandlers(instance, cb) {
    const connectorsToCleanup = [];
    const handlers = instance.handlers();
    const proxiedHandlers = new Proxy(handlers, {
      get: (target, key, receiver) => {
        if (key in handlers === false) {
          return Reflect.get(target, key, receiver);
        }
        return (el, ...args) => {
          const cleanup = handlers[key](el, ...args);
          if (!cleanup) {
            return;
          }
          connectorsToCleanup.push(cleanup);
        };
      }
    });
    cb(proxiedHandlers);
    return () => {
      connectorsToCleanup.forEach((cleanup) => {
        cleanup();
      });
    };
  }
  reflect(cb) {
    return this.createProxyHandlers(this, cb);
  }
}

export { EventHandlers };
