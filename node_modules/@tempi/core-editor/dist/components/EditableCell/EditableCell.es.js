import { jsx } from 'react/jsx-runtime';
import styled from '@emotion/styled';
import { InputNumber, Input, Form } from 'antd';
import { useState, useRef, useContext, useEffect } from 'react';
import { EditableContext } from '../EditableRow/EditableRow.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const EditableCell = (_a) => {
  var _b = _a, {
    title,
    editable,
    children,
    dataIndex,
    rowIndex,
    style,
    record,
    onChange
  } = _b, restProps = __objRest(_b, [
    "title",
    "editable",
    "children",
    "dataIndex",
    "rowIndex",
    "style",
    "record",
    "onChange"
  ]);
  const [editing, setEditing] = useState(false);
  const inputRef = useRef(null);
  const form = useContext(EditableContext);
  const save = async () => {
    try {
      await form.validateFields([dataIndex]);
      onChange(form.getFieldValue(dataIndex));
      toggleEdit();
    } catch (errInfo) {
      console.error(errInfo);
    }
  };
  useEffect(() => {
    var _a2;
    if (editing) {
      (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
    }
  }, [editing]);
  const toggleEdit = () => {
    setEditing(!editing);
    form.setFieldValue(dataIndex, record[dataIndex]);
  };
  let childNode = children;
  if (editable) {
    const RenderInput = (editable == null ? void 0 : editable.inputType) === "number" ? InputNumber : Input;
    childNode = editing ? /* @__PURE__ */ jsx(Form.Item, {
      style: { margin: 0, whiteSpace: "normal" },
      name: dataIndex,
      rules: editable == null ? void 0 : editable.rules,
      children: /* @__PURE__ */ jsx(RenderInput, {
        ref: inputRef,
        onPressEnter: save,
        onBlur: save,
        style: { width: "100%" }
      })
    }) : /* @__PURE__ */ jsx(StyledEditableCell, {
      className: "editable-cell",
      onClick: toggleEdit,
      children
    });
  }
  return /* @__PURE__ */ jsx("td", __spreadProps(__spreadValues({}, restProps), {
    style: __spreadValues({ overflow: "hidden", textOverflow: "ellipsis" }, style),
    children: childNode
  }));
};
const StyledEditableCell = styled.div`
  padding: 5px 12px;
  cursor: pointer;
  min-height: 31px;
  overflow: hidden;
  text-overflow: ellipsis;
`;

export { EditableCell, StyledEditableCell };
