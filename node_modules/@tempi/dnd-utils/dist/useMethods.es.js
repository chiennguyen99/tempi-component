import produce, { enableMapSet, enablePatches, produceWithPatches } from 'immer';
import isEqualWith from 'lodash.isequalwith';
import { useMemo, useRef, useCallback, useEffect } from 'react';
import { History, HISTORY_ACTIONS } from './History.es.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
enableMapSet();
enablePatches();
function useMethods(methodsOrOptions, initialState, queryMethods, patchListener) {
  const history = useMemo(() => new History(), []);
  let methodsFactory;
  const ignoreHistoryForActionsRef = useRef([]);
  const normalizeHistoryRef = useRef();
  if (typeof methodsOrOptions === "function") {
    methodsFactory = methodsOrOptions;
  } else {
    methodsFactory = methodsOrOptions.methods;
    ignoreHistoryForActionsRef.current = methodsOrOptions.ignoreHistoryForActions;
    normalizeHistoryRef.current = methodsOrOptions.normalizeHistory;
  }
  const patchListenerRef = useRef(patchListener);
  patchListenerRef.current = patchListener;
  const stateRef = useRef(initialState);
  const reducer = useMemo(() => {
    const { current: normalizeHistory } = normalizeHistoryRef;
    const { current: ignoreHistoryForActions } = ignoreHistoryForActionsRef;
    const { current: patchListener2 } = patchListenerRef;
    return (state, action) => {
      const query2 = queryMethods && createQuery(queryMethods, () => state, history);
      let finalState;
      let [nextState, patches, inversePatches] = produceWithPatches(
        state,
        (draft) => {
          switch (action.type) {
            case HISTORY_ACTIONS.UNDO: {
              return history.undo(draft);
            }
            case HISTORY_ACTIONS.REDO: {
              return history.redo(draft);
            }
            case HISTORY_ACTIONS.CLEAR: {
              history.clear();
              return __spreadValues({}, draft);
            }
            case HISTORY_ACTIONS.IGNORE:
            case HISTORY_ACTIONS.MERGE:
            case HISTORY_ACTIONS.THROTTLE: {
              const [type, ...params] = action.payload;
              methodsFactory(draft, query2)[type](...params);
              break;
            }
            default:
              methodsFactory(draft, query2)[action.type](...action.payload);
          }
        }
      );
      finalState = nextState;
      if (patchListener2) {
        patchListener2(
          nextState,
          state,
          { type: action.type, params: action.payload, patches },
          query2,
          (cb) => {
            const normalizedDraft = produceWithPatches(nextState, cb);
            finalState = normalizedDraft[0];
            patches = [...patches, ...normalizedDraft[1]];
            inversePatches = [...normalizedDraft[2], ...inversePatches];
          }
        );
      }
      if ([HISTORY_ACTIONS.UNDO, HISTORY_ACTIONS.REDO].includes(
        action.type
      ) && normalizeHistory) {
        finalState = produce(finalState, normalizeHistory);
      }
      if (![
        ...ignoreHistoryForActions,
        HISTORY_ACTIONS.UNDO,
        HISTORY_ACTIONS.REDO,
        HISTORY_ACTIONS.IGNORE,
        HISTORY_ACTIONS.CLEAR
      ].includes(action.type)) {
        if (action.type === HISTORY_ACTIONS.THROTTLE) {
          history.throttleAdd(
            patches,
            inversePatches,
            action.config && action.config.rate
          );
        } else if (action.type === HISTORY_ACTIONS.MERGE) {
          history.merge(patches, inversePatches);
        } else {
          history.add(patches, inversePatches);
        }
      }
      return finalState;
    };
  }, [history, methodsFactory, queryMethods]);
  const getState = useCallback(() => stateRef.current, []);
  const watcher = useMemo(() => new Watcher(getState), [getState]);
  const dispatch = useCallback(
    (action) => {
      const newState = reducer(stateRef.current, action);
      stateRef.current = newState;
      watcher.notify();
    },
    [reducer, watcher]
  );
  useEffect(() => {
    watcher.notify();
  }, [watcher]);
  const query = useMemo(
    () => !queryMethods ? [] : createQuery(queryMethods, () => stateRef.current, history),
    [history, queryMethods]
  );
  const actions = useMemo(() => {
    const actionTypes = Object.keys(methodsFactory(null, null));
    const { current: ignoreHistoryForActions } = ignoreHistoryForActionsRef;
    return __spreadProps(__spreadValues({}, actionTypes.reduce((accum, type) => {
      accum[type] = (...payload) => dispatch({ type, payload });
      return accum;
    }, {})), {
      history: {
        undo() {
          return dispatch({
            type: HISTORY_ACTIONS.UNDO
          });
        },
        redo() {
          return dispatch({
            type: HISTORY_ACTIONS.REDO
          });
        },
        clear: () => {
          return dispatch({
            type: HISTORY_ACTIONS.CLEAR
          });
        },
        throttle: (rate) => {
          return __spreadValues({}, actionTypes.filter((type) => !ignoreHistoryForActions.includes(type)).reduce((accum, type) => {
            accum[type] = (...payload) => dispatch({
              type: HISTORY_ACTIONS.THROTTLE,
              payload: [type, ...payload],
              config: {
                rate
              }
            });
            return accum;
          }, {}));
        },
        ignore: () => {
          return __spreadValues({}, actionTypes.filter((type) => !ignoreHistoryForActions.includes(type)).reduce((accum, type) => {
            accum[type] = (...payload) => dispatch({
              type: HISTORY_ACTIONS.IGNORE,
              payload: [type, ...payload]
            });
            return accum;
          }, {}));
        },
        merge: () => {
          return __spreadValues({}, actionTypes.filter((type) => !ignoreHistoryForActions.includes(type)).reduce((accum, type) => {
            accum[type] = (...payload) => dispatch({
              type: HISTORY_ACTIONS.MERGE,
              payload: [type, ...payload]
            });
            return accum;
          }, {}));
        }
      }
    });
  }, [dispatch, methodsFactory]);
  return useMemo(
    () => ({
      getState,
      subscribe: (collector, cb, collectOnCreate) => watcher.subscribe(collector, cb, collectOnCreate),
      actions,
      query,
      history
    }),
    [actions, query, watcher, getState, history]
  );
}
function createQuery(queryMethods, getState, history) {
  const queries = Object.keys(queryMethods()).reduce((accum, key) => {
    return __spreadProps(__spreadValues({}, accum), {
      [key]: (...args) => {
        return queryMethods(getState())[key](...args);
      }
    });
  }, {});
  return __spreadProps(__spreadValues({}, queries), {
    history: {
      canUndo: () => history.canUndo(),
      canRedo: () => history.canRedo()
    }
  });
}
class Watcher {
  constructor(getState) {
    this.subscribers = [];
    this.getState = getState;
  }
  subscribe(collector, onChange, collectOnCreate) {
    const subscriber = new Subscriber(
      () => collector(this.getState()),
      onChange,
      collectOnCreate
    );
    this.subscribers.push(subscriber);
    return this.unsubscribe.bind(this, subscriber);
  }
  unsubscribe(subscriber) {
    if (this.subscribers.length) {
      const index = this.subscribers.indexOf(subscriber);
      if (index > -1)
        return this.subscribers.splice(index, 1);
    }
  }
  notify() {
    this.subscribers.forEach((subscriber) => subscriber.collect());
  }
}
class Subscriber {
  constructor(collector, onChange, collectOnCreate = false) {
    this.collector = collector;
    this.onChange = onChange;
    if (collectOnCreate)
      this.collect();
  }
  collect() {
    try {
      const recollect = this.collector();
      if (!isEqualWith(recollect, this.collected)) {
        this.collected = recollect;
        if (this.onChange)
          this.onChange(this.collected);
      }
    } catch (err) {
      console.warn(err);
    }
  }
}

export { createQuery, useMethods };
